/* automatically generated by rust-bindgen 0.69.5 */

#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__iobuf() {
    const UNINIT: ::std::mem::MaybeUninit<_iobuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_iobuf>(),
        8usize,
        concat!("Size of: ", stringify!(_iobuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_iobuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_iobuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Placeholder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_Placeholder)
        )
    );
}
pub type FILE = _iobuf;
extern "C" {
    pub fn ggml_abort(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
pub const GGML_STATUS_ALLOC_FAILED: ggml_status = -2;
pub const GGML_STATUS_FAILED: ggml_status = -1;
pub const GGML_STATUS_SUCCESS: ggml_status = 0;
pub const GGML_STATUS_ABORTED: ggml_status = 1;
pub type ggml_status = ::std::os::raw::c_int;
extern "C" {
    pub fn ggml_status_to_string(status: ggml_status) -> *const ::std::os::raw::c_char;
}
pub type ggml_fp16_t = u16;
extern "C" {
    pub fn ggml_fp16_to_fp32(arg1: ggml_fp16_t) -> f32;
}
extern "C" {
    pub fn ggml_fp32_to_fp16(arg1: f32) -> ggml_fp16_t;
}
extern "C" {
    pub fn ggml_fp16_to_fp32_row(arg1: *const ggml_fp16_t, arg2: *mut f32, arg3: i64);
}
extern "C" {
    pub fn ggml_fp32_to_fp16_row(arg1: *const f32, arg2: *mut ggml_fp16_t, arg3: i64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_bf16_t {
    pub bits: u16,
}
#[test]
fn bindgen_test_layout_ggml_bf16_t() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_bf16_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_bf16_t>(),
        2usize,
        concat!("Size of: ", stringify!(ggml_bf16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_bf16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ggml_bf16_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_bf16_t),
            "::",
            stringify!(bits)
        )
    );
}
extern "C" {
    pub fn ggml_fp32_to_bf16(arg1: f32) -> ggml_bf16_t;
}
extern "C" {
    pub fn ggml_bf16_to_fp32(arg1: ggml_bf16_t) -> f32;
}
extern "C" {
    pub fn ggml_bf16_to_fp32_row(arg1: *const ggml_bf16_t, arg2: *mut f32, arg3: i64);
}
extern "C" {
    pub fn ggml_fp32_to_bf16_row_ref(arg1: *const f32, arg2: *mut ggml_bf16_t, arg3: i64);
}
extern "C" {
    pub fn ggml_fp32_to_bf16_row(arg1: *const f32, arg2: *mut ggml_bf16_t, arg3: i64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_cgraph {
    _unused: [u8; 0],
}
pub const GGML_TYPE_F32: ggml_type = 0;
pub const GGML_TYPE_F16: ggml_type = 1;
pub const GGML_TYPE_Q4_0: ggml_type = 2;
pub const GGML_TYPE_Q4_1: ggml_type = 3;
pub const GGML_TYPE_Q5_0: ggml_type = 6;
pub const GGML_TYPE_Q5_1: ggml_type = 7;
pub const GGML_TYPE_Q8_0: ggml_type = 8;
pub const GGML_TYPE_Q8_1: ggml_type = 9;
pub const GGML_TYPE_Q2_K: ggml_type = 10;
pub const GGML_TYPE_Q3_K: ggml_type = 11;
pub const GGML_TYPE_Q4_K: ggml_type = 12;
pub const GGML_TYPE_Q5_K: ggml_type = 13;
pub const GGML_TYPE_Q6_K: ggml_type = 14;
pub const GGML_TYPE_Q8_K: ggml_type = 15;
pub const GGML_TYPE_IQ2_XXS: ggml_type = 16;
pub const GGML_TYPE_IQ2_XS: ggml_type = 17;
pub const GGML_TYPE_IQ3_XXS: ggml_type = 18;
pub const GGML_TYPE_IQ1_S: ggml_type = 19;
pub const GGML_TYPE_IQ4_NL: ggml_type = 20;
pub const GGML_TYPE_IQ3_S: ggml_type = 21;
pub const GGML_TYPE_IQ2_S: ggml_type = 22;
pub const GGML_TYPE_IQ4_XS: ggml_type = 23;
pub const GGML_TYPE_I8: ggml_type = 24;
pub const GGML_TYPE_I16: ggml_type = 25;
pub const GGML_TYPE_I32: ggml_type = 26;
pub const GGML_TYPE_I64: ggml_type = 27;
pub const GGML_TYPE_F64: ggml_type = 28;
pub const GGML_TYPE_IQ1_M: ggml_type = 29;
pub const GGML_TYPE_BF16: ggml_type = 30;
pub const GGML_TYPE_TQ1_0: ggml_type = 34;
pub const GGML_TYPE_TQ2_0: ggml_type = 35;
pub const GGML_TYPE_COUNT: ggml_type = 39;
pub type ggml_type = ::std::os::raw::c_int;
pub const GGML_PREC_DEFAULT: ggml_prec = 0;
pub const GGML_PREC_F32: ggml_prec = 1;
pub type ggml_prec = ::std::os::raw::c_int;
pub const GGML_FTYPE_UNKNOWN: ggml_ftype = -1;
pub const GGML_FTYPE_ALL_F32: ggml_ftype = 0;
pub const GGML_FTYPE_MOSTLY_F16: ggml_ftype = 1;
pub const GGML_FTYPE_MOSTLY_Q4_0: ggml_ftype = 2;
pub const GGML_FTYPE_MOSTLY_Q4_1: ggml_ftype = 3;
pub const GGML_FTYPE_MOSTLY_Q4_1_SOME_F16: ggml_ftype = 4;
pub const GGML_FTYPE_MOSTLY_Q8_0: ggml_ftype = 7;
pub const GGML_FTYPE_MOSTLY_Q5_0: ggml_ftype = 8;
pub const GGML_FTYPE_MOSTLY_Q5_1: ggml_ftype = 9;
pub const GGML_FTYPE_MOSTLY_Q2_K: ggml_ftype = 10;
pub const GGML_FTYPE_MOSTLY_Q3_K: ggml_ftype = 11;
pub const GGML_FTYPE_MOSTLY_Q4_K: ggml_ftype = 12;
pub const GGML_FTYPE_MOSTLY_Q5_K: ggml_ftype = 13;
pub const GGML_FTYPE_MOSTLY_Q6_K: ggml_ftype = 14;
pub const GGML_FTYPE_MOSTLY_IQ2_XXS: ggml_ftype = 15;
pub const GGML_FTYPE_MOSTLY_IQ2_XS: ggml_ftype = 16;
pub const GGML_FTYPE_MOSTLY_IQ3_XXS: ggml_ftype = 17;
pub const GGML_FTYPE_MOSTLY_IQ1_S: ggml_ftype = 18;
pub const GGML_FTYPE_MOSTLY_IQ4_NL: ggml_ftype = 19;
pub const GGML_FTYPE_MOSTLY_IQ3_S: ggml_ftype = 20;
pub const GGML_FTYPE_MOSTLY_IQ2_S: ggml_ftype = 21;
pub const GGML_FTYPE_MOSTLY_IQ4_XS: ggml_ftype = 22;
pub const GGML_FTYPE_MOSTLY_IQ1_M: ggml_ftype = 23;
pub const GGML_FTYPE_MOSTLY_BF16: ggml_ftype = 24;
pub type ggml_ftype = ::std::os::raw::c_int;
pub const GGML_OP_NONE: ggml_op = 0;
pub const GGML_OP_DUP: ggml_op = 1;
pub const GGML_OP_ADD: ggml_op = 2;
pub const GGML_OP_ADD1: ggml_op = 3;
pub const GGML_OP_ACC: ggml_op = 4;
pub const GGML_OP_SUB: ggml_op = 5;
pub const GGML_OP_MUL: ggml_op = 6;
pub const GGML_OP_DIV: ggml_op = 7;
pub const GGML_OP_SQR: ggml_op = 8;
pub const GGML_OP_SQRT: ggml_op = 9;
pub const GGML_OP_LOG: ggml_op = 10;
pub const GGML_OP_SIN: ggml_op = 11;
pub const GGML_OP_COS: ggml_op = 12;
pub const GGML_OP_SUM: ggml_op = 13;
pub const GGML_OP_SUM_ROWS: ggml_op = 14;
pub const GGML_OP_MEAN: ggml_op = 15;
pub const GGML_OP_ARGMAX: ggml_op = 16;
pub const GGML_OP_COUNT_EQUAL: ggml_op = 17;
pub const GGML_OP_REPEAT: ggml_op = 18;
pub const GGML_OP_REPEAT_BACK: ggml_op = 19;
pub const GGML_OP_CONCAT: ggml_op = 20;
pub const GGML_OP_SILU_BACK: ggml_op = 21;
pub const GGML_OP_NORM: ggml_op = 22;
pub const GGML_OP_RMS_NORM: ggml_op = 23;
pub const GGML_OP_RMS_NORM_BACK: ggml_op = 24;
pub const GGML_OP_GROUP_NORM: ggml_op = 25;
pub const GGML_OP_L2_NORM: ggml_op = 26;
pub const GGML_OP_MUL_MAT: ggml_op = 27;
pub const GGML_OP_MUL_MAT_ID: ggml_op = 28;
pub const GGML_OP_OUT_PROD: ggml_op = 29;
pub const GGML_OP_SCALE: ggml_op = 30;
pub const GGML_OP_SET: ggml_op = 31;
pub const GGML_OP_CPY: ggml_op = 32;
pub const GGML_OP_CONT: ggml_op = 33;
pub const GGML_OP_RESHAPE: ggml_op = 34;
pub const GGML_OP_VIEW: ggml_op = 35;
pub const GGML_OP_PERMUTE: ggml_op = 36;
pub const GGML_OP_TRANSPOSE: ggml_op = 37;
pub const GGML_OP_GET_ROWS: ggml_op = 38;
pub const GGML_OP_GET_ROWS_BACK: ggml_op = 39;
pub const GGML_OP_DIAG: ggml_op = 40;
pub const GGML_OP_DIAG_MASK_INF: ggml_op = 41;
pub const GGML_OP_DIAG_MASK_ZERO: ggml_op = 42;
pub const GGML_OP_SOFT_MAX: ggml_op = 43;
pub const GGML_OP_SOFT_MAX_BACK: ggml_op = 44;
pub const GGML_OP_ROPE: ggml_op = 45;
pub const GGML_OP_ROPE_BACK: ggml_op = 46;
pub const GGML_OP_CLAMP: ggml_op = 47;
pub const GGML_OP_CONV_TRANSPOSE_1D: ggml_op = 48;
pub const GGML_OP_IM2COL: ggml_op = 49;
pub const GGML_OP_IM2COL_BACK: ggml_op = 50;
pub const GGML_OP_CONV_TRANSPOSE_2D: ggml_op = 51;
pub const GGML_OP_POOL_1D: ggml_op = 52;
pub const GGML_OP_POOL_2D: ggml_op = 53;
pub const GGML_OP_POOL_2D_BACK: ggml_op = 54;
pub const GGML_OP_UPSCALE: ggml_op = 55;
pub const GGML_OP_PAD: ggml_op = 56;
pub const GGML_OP_PAD_REFLECT_1D: ggml_op = 57;
pub const GGML_OP_ARANGE: ggml_op = 58;
pub const GGML_OP_TIMESTEP_EMBEDDING: ggml_op = 59;
pub const GGML_OP_ARGSORT: ggml_op = 60;
pub const GGML_OP_LEAKY_RELU: ggml_op = 61;
pub const GGML_OP_FLASH_ATTN_EXT: ggml_op = 62;
pub const GGML_OP_FLASH_ATTN_BACK: ggml_op = 63;
pub const GGML_OP_SSM_CONV: ggml_op = 64;
pub const GGML_OP_SSM_SCAN: ggml_op = 65;
pub const GGML_OP_WIN_PART: ggml_op = 66;
pub const GGML_OP_WIN_UNPART: ggml_op = 67;
pub const GGML_OP_GET_REL_POS: ggml_op = 68;
pub const GGML_OP_ADD_REL_POS: ggml_op = 69;
pub const GGML_OP_RWKV_WKV6: ggml_op = 70;
pub const GGML_OP_GATED_LINEAR_ATTN: ggml_op = 71;
pub const GGML_OP_RWKV_WKV7: ggml_op = 72;
pub const GGML_OP_UNARY: ggml_op = 73;
pub const GGML_OP_MAP_UNARY: ggml_op = 74;
pub const GGML_OP_MAP_BINARY: ggml_op = 75;
pub const GGML_OP_MAP_CUSTOM1_F32: ggml_op = 76;
pub const GGML_OP_MAP_CUSTOM2_F32: ggml_op = 77;
pub const GGML_OP_MAP_CUSTOM3_F32: ggml_op = 78;
pub const GGML_OP_MAP_CUSTOM1: ggml_op = 79;
pub const GGML_OP_MAP_CUSTOM2: ggml_op = 80;
pub const GGML_OP_MAP_CUSTOM3: ggml_op = 81;
pub const GGML_OP_CROSS_ENTROPY_LOSS: ggml_op = 82;
pub const GGML_OP_CROSS_ENTROPY_LOSS_BACK: ggml_op = 83;
pub const GGML_OP_OPT_STEP_ADAMW: ggml_op = 84;
pub const GGML_OP_COUNT: ggml_op = 85;
pub type ggml_op = ::std::os::raw::c_int;
pub const GGML_UNARY_OP_ABS: ggml_unary_op = 0;
pub const GGML_UNARY_OP_SGN: ggml_unary_op = 1;
pub const GGML_UNARY_OP_NEG: ggml_unary_op = 2;
pub const GGML_UNARY_OP_STEP: ggml_unary_op = 3;
pub const GGML_UNARY_OP_TANH: ggml_unary_op = 4;
pub const GGML_UNARY_OP_ELU: ggml_unary_op = 5;
pub const GGML_UNARY_OP_RELU: ggml_unary_op = 6;
pub const GGML_UNARY_OP_SIGMOID: ggml_unary_op = 7;
pub const GGML_UNARY_OP_GELU: ggml_unary_op = 8;
pub const GGML_UNARY_OP_GELU_QUICK: ggml_unary_op = 9;
pub const GGML_UNARY_OP_SILU: ggml_unary_op = 10;
pub const GGML_UNARY_OP_HARDSWISH: ggml_unary_op = 11;
pub const GGML_UNARY_OP_HARDSIGMOID: ggml_unary_op = 12;
pub const GGML_UNARY_OP_EXP: ggml_unary_op = 13;
pub const GGML_UNARY_OP_COUNT: ggml_unary_op = 14;
pub type ggml_unary_op = ::std::os::raw::c_int;
pub const GGML_OBJECT_TYPE_TENSOR: ggml_object_type = 0;
pub const GGML_OBJECT_TYPE_GRAPH: ggml_object_type = 1;
pub const GGML_OBJECT_TYPE_WORK_BUFFER: ggml_object_type = 2;
pub type ggml_object_type = ::std::os::raw::c_int;
pub const GGML_LOG_LEVEL_NONE: ggml_log_level = 0;
pub const GGML_LOG_LEVEL_DEBUG: ggml_log_level = 1;
pub const GGML_LOG_LEVEL_INFO: ggml_log_level = 2;
pub const GGML_LOG_LEVEL_WARN: ggml_log_level = 3;
pub const GGML_LOG_LEVEL_ERROR: ggml_log_level = 4;
pub const GGML_LOG_LEVEL_CONT: ggml_log_level = 5;
pub type ggml_log_level = ::std::os::raw::c_int;
pub const GGML_TENSOR_FLAG_INPUT: ggml_tensor_flag = 1;
pub const GGML_TENSOR_FLAG_OUTPUT: ggml_tensor_flag = 2;
pub const GGML_TENSOR_FLAG_PARAM: ggml_tensor_flag = 4;
pub const GGML_TENSOR_FLAG_LOSS: ggml_tensor_flag = 8;
pub type ggml_tensor_flag = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_init_params {
    pub mem_size: usize,
    pub mem_buffer: *mut ::std::os::raw::c_void,
    pub no_alloc: bool,
}
#[test]
fn bindgen_test_layout_ggml_init_params() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_init_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_init_params>(),
        24usize,
        concat!("Size of: ", stringify!(ggml_init_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_init_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_init_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_init_params),
            "::",
            stringify!(mem_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_init_params),
            "::",
            stringify!(mem_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_alloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_init_params),
            "::",
            stringify!(no_alloc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_tensor {
    pub type_: ggml_type,
    pub buffer: *mut ggml_backend_buffer,
    pub ne: [i64; 4usize],
    pub nb: [usize; 4usize],
    pub op: ggml_op,
    pub op_params: [i32; 16usize],
    pub flags: i32,
    pub src: [*mut ggml_tensor; 10usize],
    pub view_src: *mut ggml_tensor,
    pub view_offs: usize,
    pub data: *mut ::std::os::raw::c_void,
    pub name: [::std::os::raw::c_char; 64usize],
    pub extra: *mut ::std::os::raw::c_void,
    pub padding: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_ggml_tensor() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_tensor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_tensor>(),
        336usize,
        concat!("Size of: ", stringify!(ggml_tensor))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_tensor>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_tensor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(ne)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(nb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op_params) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(op_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).view_src) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(view_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).view_offs) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(view_offs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(padding)
        )
    );
}
pub type ggml_abort_callback =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>;
pub type ggml_guid = [u8; 16usize];
pub type ggml_guid_t = *mut ggml_guid;
extern "C" {
    pub fn ggml_guid_matches(guid_a: ggml_guid_t, guid_b: ggml_guid_t) -> bool;
}
extern "C" {
    pub fn ggml_time_init();
}
extern "C" {
    pub fn ggml_time_ms() -> i64;
}
extern "C" {
    pub fn ggml_time_us() -> i64;
}
extern "C" {
    pub fn ggml_cycles() -> i64;
}
extern "C" {
    pub fn ggml_cycles_per_ms() -> i64;
}
extern "C" {
    pub fn ggml_fopen(
        fname: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ggml_print_object(obj: *const ggml_object);
}
extern "C" {
    pub fn ggml_print_objects(ctx: *const ggml_context);
}
extern "C" {
    pub fn ggml_nelements(tensor: *const ggml_tensor) -> i64;
}
extern "C" {
    pub fn ggml_nrows(tensor: *const ggml_tensor) -> i64;
}
extern "C" {
    pub fn ggml_nbytes(tensor: *const ggml_tensor) -> usize;
}
extern "C" {
    pub fn ggml_nbytes_pad(tensor: *const ggml_tensor) -> usize;
}
extern "C" {
    pub fn ggml_blck_size(type_: ggml_type) -> i64;
}
extern "C" {
    pub fn ggml_type_size(type_: ggml_type) -> usize;
}
extern "C" {
    pub fn ggml_row_size(type_: ggml_type, ne: i64) -> usize;
}
extern "C" {
    pub fn ggml_type_sizef(type_: ggml_type) -> f64;
}
extern "C" {
    pub fn ggml_type_name(type_: ggml_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_op_name(op: ggml_op) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_op_symbol(op: ggml_op) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_unary_op_name(op: ggml_unary_op) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_op_desc(t: *const ggml_tensor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_element_size(tensor: *const ggml_tensor) -> usize;
}
extern "C" {
    pub fn ggml_is_quantized(type_: ggml_type) -> bool;
}
extern "C" {
    pub fn ggml_ftype_to_ggml_type(ftype: ggml_ftype) -> ggml_type;
}
extern "C" {
    pub fn ggml_is_transposed(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_permuted(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_empty(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_scalar(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_vector(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_matrix(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_3d(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_n_dims(tensor: *const ggml_tensor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_is_contiguous(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_contiguous_0(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_contiguous_1(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_contiguous_2(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_are_same_shape(t0: *const ggml_tensor, t1: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_are_same_stride(t0: *const ggml_tensor, t1: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_can_repeat(t0: *const ggml_tensor, t1: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_tensor_overhead() -> usize;
}
extern "C" {
    pub fn ggml_validate_row_data(
        type_: ggml_type,
        data: *const ::std::os::raw::c_void,
        nbytes: usize,
    ) -> bool;
}
extern "C" {
    pub fn ggml_init(params: ggml_init_params) -> *mut ggml_context;
}
extern "C" {
    pub fn ggml_reset(ctx: *mut ggml_context);
}
extern "C" {
    pub fn ggml_free(ctx: *mut ggml_context);
}
extern "C" {
    pub fn ggml_used_mem(ctx: *const ggml_context) -> usize;
}
extern "C" {
    pub fn ggml_get_no_alloc(ctx: *mut ggml_context) -> bool;
}
extern "C" {
    pub fn ggml_set_no_alloc(ctx: *mut ggml_context, no_alloc: bool);
}
extern "C" {
    pub fn ggml_get_mem_buffer(ctx: *const ggml_context) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ggml_get_mem_size(ctx: *const ggml_context) -> usize;
}
extern "C" {
    pub fn ggml_get_max_tensor_size(ctx: *const ggml_context) -> usize;
}
extern "C" {
    pub fn ggml_new_tensor(
        ctx: *mut ggml_context,
        type_: ggml_type,
        n_dims: ::std::os::raw::c_int,
        ne: *const i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_tensor_1d(
        ctx: *mut ggml_context,
        type_: ggml_type,
        ne0: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_tensor_2d(
        ctx: *mut ggml_context,
        type_: ggml_type,
        ne0: i64,
        ne1: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_tensor_3d(
        ctx: *mut ggml_context,
        type_: ggml_type,
        ne0: i64,
        ne1: i64,
        ne2: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_tensor_4d(
        ctx: *mut ggml_context,
        type_: ggml_type,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        ne3: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_buffer(ctx: *mut ggml_context, nbytes: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ggml_dup_tensor(ctx: *mut ggml_context, src: *const ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_view_tensor(ctx: *mut ggml_context, src: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_first_tensor(ctx: *const ggml_context) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_next_tensor(
        ctx: *const ggml_context,
        tensor: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_tensor(
        ctx: *mut ggml_context,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_unravel_index(
        tensor: *const ggml_tensor,
        i: i64,
        i0: *mut i64,
        i1: *mut i64,
        i2: *mut i64,
        i3: *mut i64,
    );
}
extern "C" {
    pub fn ggml_get_unary_op(tensor: *const ggml_tensor) -> ggml_unary_op;
}
extern "C" {
    pub fn ggml_get_data(tensor: *const ggml_tensor) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ggml_get_data_f32(tensor: *const ggml_tensor) -> *mut f32;
}
extern "C" {
    pub fn ggml_get_name(tensor: *const ggml_tensor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_set_name(
        tensor: *mut ggml_tensor,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_format_name(
        tensor: *mut ggml_tensor,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_input(tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_set_output(tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_set_param(ctx: *mut ggml_context, tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_set_loss(tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_dup(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_dup_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add_cast(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        type_: ggml_type,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add1(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add1_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_acc(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        nb2: usize,
        nb3: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_acc_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        nb2: usize,
        nb3: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sub(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sub_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_mul(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_mul_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_div(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_div_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sqr(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sqr_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sqrt(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sqrt_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_log(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_log_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sin(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sin_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cos(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cos_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sum(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sum_rows(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_mean(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_argmax(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_count_equal(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_repeat(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_repeat_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_concat(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        dim: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_abs(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_abs_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sgn(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sgn_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_neg(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_neg_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_step(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_step_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_tanh(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_tanh_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_elu(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_elu_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_relu(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_leaky_relu(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        negative_slope: f32,
        inplace: bool,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_relu_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sigmoid(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sigmoid_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gelu(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gelu_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gelu_quick(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gelu_quick_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor)
        -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_silu(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_silu_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_silu_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_hardswish(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_hardsigmoid(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_exp(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_exp_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_norm(ctx: *mut ggml_context, a: *mut ggml_tensor, eps: f32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_norm_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rms_norm(ctx: *mut ggml_context, a: *mut ggml_tensor, eps: f32)
        -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rms_norm_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_group_norm(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_groups: ::std::os::raw::c_int,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_group_norm_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_groups: ::std::os::raw::c_int,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_l2_norm(ctx: *mut ggml_context, a: *mut ggml_tensor, eps: f32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_l2_norm_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rms_norm_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_mul_mat(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_mul_mat_set_prec(a: *mut ggml_tensor, prec: ggml_prec);
}
extern "C" {
    pub fn ggml_mul_mat_id(
        ctx: *mut ggml_context,
        as_: *mut ggml_tensor,
        b: *mut ggml_tensor,
        ids: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_out_prod(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_scale(ctx: *mut ggml_context, a: *mut ggml_tensor, s: f32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_scale_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        s: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        nb2: usize,
        nb3: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        nb2: usize,
        nb3: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_1d_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_2d_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cpy(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cast(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        type_: ggml_type,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cont(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cont_1d(ctx: *mut ggml_context, a: *mut ggml_tensor, ne0: i64) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cont_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cont_3d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cont_4d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        ne3: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reshape(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reshape_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reshape_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reshape_3d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reshape_4d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        ne3: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_view_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_view_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        nb1: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_view_3d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        nb1: usize,
        nb2: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_view_4d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        ne3: i64,
        nb1: usize,
        nb2: usize,
        nb3: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_permute(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        axis0: ::std::os::raw::c_int,
        axis1: ::std::os::raw::c_int,
        axis2: ::std::os::raw::c_int,
        axis3: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_transpose(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_rows(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_rows_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_diag(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_diag_mask_inf(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_past: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_diag_mask_inf_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_past: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_diag_mask_zero(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_past: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_diag_mask_zero_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_past: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_soft_max(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_soft_max_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_soft_max_ext(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        mask: *mut ggml_tensor,
        scale: f32,
        max_bias: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_soft_max_ext_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        scale: f32,
        max_bias: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_soft_max_ext_back_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        scale: f32,
        max_bias: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_ext(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_multi(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        sections: *mut ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_ext_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_custom(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_custom_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_yarn_corr_dims(
        n_dims: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        beta_fast: f32,
        beta_slow: f32,
        dims: *mut f32,
    );
}
extern "C" {
    pub fn ggml_rope_ext_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_multi_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        sections: *mut ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_clamp(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        min: f32,
        max: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_im2col(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
        is_2D: bool,
        dst_type: ggml_type,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_im2col_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        ne: *mut i64,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
        is_2D: bool,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_1d_ph(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s: ::std::os::raw::c_int,
        d: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_1d_dw(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_1d_dw_ph(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_transpose_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_2d_sk_p0(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_2d_s1_ph(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_2d_dw(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_transpose_2d_p0(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        stride: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
pub const GGML_OP_POOL_MAX: ggml_op_pool = 0;
pub const GGML_OP_POOL_AVG: ggml_op_pool = 1;
pub const GGML_OP_POOL_COUNT: ggml_op_pool = 2;
pub type ggml_op_pool = ::std::os::raw::c_int;
extern "C" {
    pub fn ggml_pool_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        op: ggml_op_pool,
        k0: ::std::os::raw::c_int,
        s0: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_pool_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        op: ggml_op_pool,
        k0: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: f32,
        p1: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_pool_2d_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        af: *mut ggml_tensor,
        op: ggml_op_pool,
        k0: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: f32,
        p1: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_upscale(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        scale_factor: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_upscale_ext(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: ::std::os::raw::c_int,
        ne1: ::std::os::raw::c_int,
        ne2: ::std::os::raw::c_int,
        ne3: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_pad(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        p2: ::std::os::raw::c_int,
        p3: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_pad_reflect_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_timestep_embedding(
        ctx: *mut ggml_context,
        timesteps: *mut ggml_tensor,
        dim: ::std::os::raw::c_int,
        max_period: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
pub const GGML_SORT_ORDER_ASC: ggml_sort_order = 0;
pub const GGML_SORT_ORDER_DESC: ggml_sort_order = 1;
pub type ggml_sort_order = ::std::os::raw::c_int;
extern "C" {
    pub fn ggml_argsort(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        order: ggml_sort_order,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_arange(
        ctx: *mut ggml_context,
        start: f32,
        stop: f32,
        step: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_top_k(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        k: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_flash_attn_ext(
        ctx: *mut ggml_context,
        q: *mut ggml_tensor,
        k: *mut ggml_tensor,
        v: *mut ggml_tensor,
        mask: *mut ggml_tensor,
        scale: f32,
        max_bias: f32,
        logit_softcap: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_flash_attn_ext_set_prec(a: *mut ggml_tensor, prec: ggml_prec);
}
extern "C" {
    pub fn ggml_flash_attn_ext_get_prec(a: *const ggml_tensor) -> ggml_prec;
}
extern "C" {
    pub fn ggml_flash_attn_back(
        ctx: *mut ggml_context,
        q: *mut ggml_tensor,
        k: *mut ggml_tensor,
        v: *mut ggml_tensor,
        d: *mut ggml_tensor,
        masked: bool,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_ssm_conv(
        ctx: *mut ggml_context,
        sx: *mut ggml_tensor,
        c: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_ssm_scan(
        ctx: *mut ggml_context,
        s: *mut ggml_tensor,
        x: *mut ggml_tensor,
        dt: *mut ggml_tensor,
        A: *mut ggml_tensor,
        B: *mut ggml_tensor,
        C: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_win_part(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        w: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_win_unpart(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        w0: ::std::os::raw::c_int,
        h0: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_unary(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        op: ggml_unary_op,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_unary_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        op: ggml_unary_op,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_rel_pos(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        qh: ::std::os::raw::c_int,
        kh: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add_rel_pos(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        pw: *mut ggml_tensor,
        ph: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add_rel_pos_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        pw: *mut ggml_tensor,
        ph: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rwkv_wkv6(
        ctx: *mut ggml_context,
        k: *mut ggml_tensor,
        v: *mut ggml_tensor,
        r: *mut ggml_tensor,
        tf: *mut ggml_tensor,
        td: *mut ggml_tensor,
        state: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gated_linear_attn(
        ctx: *mut ggml_context,
        k: *mut ggml_tensor,
        v: *mut ggml_tensor,
        q: *mut ggml_tensor,
        g: *mut ggml_tensor,
        state: *mut ggml_tensor,
        scale: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rwkv_wkv7(
        ctx: *mut ggml_context,
        r: *mut ggml_tensor,
        w: *mut ggml_tensor,
        k: *mut ggml_tensor,
        v: *mut ggml_tensor,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        state: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
pub type ggml_unary_op_f32_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut f32, arg3: *const f32),
>;
pub type ggml_binary_op_f32_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut f32,
        arg3: *const f32,
        arg4: *const f32,
    ),
>;
pub type ggml_custom1_op_f32_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ggml_tensor, arg2: *const ggml_tensor)>;
pub type ggml_custom2_op_f32_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ggml_tensor,
        arg2: *const ggml_tensor,
        arg3: *const ggml_tensor,
    ),
>;
pub type ggml_custom3_op_f32_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ggml_tensor,
        arg2: *const ggml_tensor,
        arg3: *const ggml_tensor,
        arg4: *const ggml_tensor,
    ),
>;
extern "C" {
    pub fn ggml_map_unary_f32(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        fun: ggml_unary_op_f32_t,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_unary_inplace_f32(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        fun: ggml_unary_op_f32_t,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_binary_f32(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        fun: ggml_binary_op_f32_t,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_binary_inplace_f32(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        fun: ggml_binary_op_f32_t,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom1_f32(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        fun: ggml_custom1_op_f32_t,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom1_inplace_f32(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        fun: ggml_custom1_op_f32_t,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom2_f32(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        fun: ggml_custom2_op_f32_t,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom2_inplace_f32(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        fun: ggml_custom2_op_f32_t,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom3_f32(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        fun: ggml_custom3_op_f32_t,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom3_inplace_f32(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        fun: ggml_custom3_op_f32_t,
    ) -> *mut ggml_tensor;
}
pub type ggml_custom1_op_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst: *mut ggml_tensor,
        a: *const ggml_tensor,
        ith: ::std::os::raw::c_int,
        nth: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
pub type ggml_custom2_op_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst: *mut ggml_tensor,
        a: *const ggml_tensor,
        b: *const ggml_tensor,
        ith: ::std::os::raw::c_int,
        nth: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
pub type ggml_custom3_op_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst: *mut ggml_tensor,
        a: *const ggml_tensor,
        b: *const ggml_tensor,
        c: *const ggml_tensor,
        ith: ::std::os::raw::c_int,
        nth: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn ggml_map_custom1(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        fun: ggml_custom1_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom1_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        fun: ggml_custom1_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom2(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        fun: ggml_custom2_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom2_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        fun: ggml_custom2_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom3(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        fun: ggml_custom3_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom3_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        fun: ggml_custom3_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cross_entropy_loss(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cross_entropy_loss_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_step_adamw(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        grad: *mut ggml_tensor,
        m: *mut ggml_tensor,
        v: *mut ggml_tensor,
        adamw_params: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_build_forward_expand(cgraph: *mut ggml_cgraph, tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_build_backward_expand(
        ctx_static: *mut ggml_context,
        ctx_compute: *mut ggml_context,
        cgraph: *mut ggml_cgraph,
        accumulate: bool,
    );
}
extern "C" {
    pub fn ggml_new_graph(ctx: *mut ggml_context) -> *mut ggml_cgraph;
}
extern "C" {
    pub fn ggml_new_graph_custom(
        ctx: *mut ggml_context,
        size: usize,
        grads: bool,
    ) -> *mut ggml_cgraph;
}
extern "C" {
    pub fn ggml_graph_dup(ctx: *mut ggml_context, cgraph: *mut ggml_cgraph) -> *mut ggml_cgraph;
}
extern "C" {
    pub fn ggml_graph_cpy(src: *mut ggml_cgraph, dst: *mut ggml_cgraph);
}
extern "C" {
    pub fn ggml_graph_reset(cgraph: *mut ggml_cgraph);
}
extern "C" {
    pub fn ggml_graph_clear(cgraph: *mut ggml_cgraph);
}
extern "C" {
    pub fn ggml_graph_size(cgraph: *mut ggml_cgraph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_graph_node(cgraph: *mut ggml_cgraph, i: ::std::os::raw::c_int) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_graph_nodes(cgraph: *mut ggml_cgraph) -> *mut *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_graph_n_nodes(cgraph: *mut ggml_cgraph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_graph_add_node(cgraph: *mut ggml_cgraph, tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_graph_overhead() -> usize;
}
extern "C" {
    pub fn ggml_graph_overhead_custom(size: usize, grads: bool) -> usize;
}
extern "C" {
    pub fn ggml_graph_get_tensor(
        cgraph: *const ggml_cgraph,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_graph_get_grad(
        cgraph: *const ggml_cgraph,
        node: *const ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_graph_get_grad_acc(
        cgraph: *const ggml_cgraph,
        node: *const ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_graph_export(cgraph: *const ggml_cgraph, fname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ggml_graph_import(
        fname: *const ::std::os::raw::c_char,
        ctx_data: *mut *mut ggml_context,
        ctx_eval: *mut *mut ggml_context,
    ) -> *mut ggml_cgraph;
}
extern "C" {
    pub fn ggml_graph_print(cgraph: *const ggml_cgraph);
}
extern "C" {
    pub fn ggml_graph_dump_dot(
        gb: *const ggml_cgraph,
        gf: *const ggml_cgraph,
        filename: *const ::std::os::raw::c_char,
    );
}
pub type ggml_log_callback = ::std::option::Option<
    unsafe extern "C" fn(
        level: ggml_log_level,
        text: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn ggml_log_set(log_callback: ggml_log_callback, user_data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ggml_set_zero(tensor: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_quantize_init(type_: ggml_type);
}
extern "C" {
    pub fn ggml_quantize_free();
}
extern "C" {
    pub fn ggml_quantize_requires_imatrix(type_: ggml_type) -> bool;
}
extern "C" {
    pub fn ggml_quantize_chunk(
        type_: ggml_type,
        src: *const f32,
        dst: *mut ::std::os::raw::c_void,
        start: i64,
        nrows: i64,
        n_per_row: i64,
        imatrix: *const f32,
    ) -> usize;
}
pub type ggml_to_float_t = ::std::option::Option<
    unsafe extern "C" fn(x: *const ::std::os::raw::c_void, y: *mut f32, k: i64),
>;
pub type ggml_from_float_t = ::std::option::Option<
    unsafe extern "C" fn(x: *const f32, y: *mut ::std::os::raw::c_void, k: i64),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_type_traits {
    pub type_name: *const ::std::os::raw::c_char,
    pub blck_size: i64,
    pub blck_size_interleave: i64,
    pub type_size: usize,
    pub is_quantized: bool,
    pub to_float: ggml_to_float_t,
    pub from_float_ref: ggml_from_float_t,
}
#[test]
fn bindgen_test_layout_ggml_type_traits() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_type_traits> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_type_traits>(),
        56usize,
        concat!("Size of: ", stringify!(ggml_type_traits))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_type_traits>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_type_traits))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blck_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(blck_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blck_size_interleave) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(blck_size_interleave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(type_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_quantized) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(is_quantized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_float) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(to_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_float_ref) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(from_float_ref)
        )
    );
}
extern "C" {
    pub fn ggml_get_type_traits(type_: ggml_type) -> *const ggml_type_traits;
}
pub const GGML_SCHED_PRIO_NORMAL: ggml_sched_priority = 0;
pub const GGML_SCHED_PRIO_MEDIUM: ggml_sched_priority = 1;
pub const GGML_SCHED_PRIO_HIGH: ggml_sched_priority = 2;
pub const GGML_SCHED_PRIO_REALTIME: ggml_sched_priority = 3;
pub type ggml_sched_priority = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_threadpool_params {
    pub cpumask: [bool; 512usize],
    pub n_threads: ::std::os::raw::c_int,
    pub prio: ggml_sched_priority,
    pub poll: u32,
    pub strict_cpu: bool,
    pub paused: bool,
}
#[test]
fn bindgen_test_layout_ggml_threadpool_params() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_threadpool_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_threadpool_params>(),
        528usize,
        concat!("Size of: ", stringify!(ggml_threadpool_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_threadpool_params>(),
        4usize,
        concat!("Alignment of ", stringify!(ggml_threadpool_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpumask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(cpumask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_threads) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(n_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prio) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strict_cpu) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(strict_cpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paused) as usize - ptr as usize },
        525usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(paused)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_threadpool {
    _unused: [u8; 0],
}
pub type ggml_threadpool_t = *mut ggml_threadpool;
extern "C" {
    pub fn ggml_threadpool_params_default(
        n_threads: ::std::os::raw::c_int,
    ) -> ggml_threadpool_params;
}
extern "C" {
    pub fn ggml_threadpool_params_init(
        p: *mut ggml_threadpool_params,
        n_threads: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ggml_threadpool_params_match(
        p0: *const ggml_threadpool_params,
        p1: *const ggml_threadpool_params,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_buffer_type {
    _unused: [u8; 0],
}
pub type ggml_backend_buffer_type_t = *mut ggml_backend_buffer_type;
pub type ggml_backend_buffer_t = *mut ggml_backend_buffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend {
    _unused: [u8; 0],
}
pub type ggml_backend_t = *mut ggml_backend;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_tallocr {
    pub buffer: ggml_backend_buffer_t,
    pub base: *mut ::std::os::raw::c_void,
    pub alignment: usize,
    pub offset: usize,
}
#[test]
fn bindgen_test_layout_ggml_tallocr() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_tallocr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_tallocr>(),
        32usize,
        concat!("Size of: ", stringify!(ggml_tallocr))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_tallocr>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_tallocr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tallocr),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tallocr),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tallocr),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tallocr),
            "::",
            stringify!(offset)
        )
    );
}
extern "C" {
    pub fn ggml_tallocr_new(buffer: ggml_backend_buffer_t) -> ggml_tallocr;
}
extern "C" {
    pub fn ggml_tallocr_alloc(talloc: *mut ggml_tallocr, tensor: *mut ggml_tensor) -> ggml_status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_gallocr {
    _unused: [u8; 0],
}
pub type ggml_gallocr_t = *mut ggml_gallocr;
extern "C" {
    pub fn ggml_gallocr_new(buft: ggml_backend_buffer_type_t) -> ggml_gallocr_t;
}
extern "C" {
    pub fn ggml_gallocr_new_n(
        bufts: *mut ggml_backend_buffer_type_t,
        n_bufs: ::std::os::raw::c_int,
    ) -> ggml_gallocr_t;
}
extern "C" {
    pub fn ggml_gallocr_free(galloc: ggml_gallocr_t);
}
extern "C" {
    pub fn ggml_gallocr_reserve(galloc: ggml_gallocr_t, graph: *mut ggml_cgraph) -> bool;
}
extern "C" {
    pub fn ggml_gallocr_reserve_n(
        galloc: ggml_gallocr_t,
        graph: *mut ggml_cgraph,
        node_buffer_ids: *const ::std::os::raw::c_int,
        leaf_buffer_ids: *const ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn ggml_gallocr_alloc_graph(galloc: ggml_gallocr_t, graph: *mut ggml_cgraph) -> bool;
}
extern "C" {
    pub fn ggml_gallocr_get_buffer_size(
        galloc: ggml_gallocr_t,
        buffer_id: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    pub fn ggml_backend_alloc_ctx_tensors_from_buft(
        ctx: *mut ggml_context,
        buft: ggml_backend_buffer_type_t,
    ) -> *mut ggml_backend_buffer;
}
extern "C" {
    pub fn ggml_backend_alloc_ctx_tensors(
        ctx: *mut ggml_context,
        backend: ggml_backend_t,
    ) -> *mut ggml_backend_buffer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_event {
    _unused: [u8; 0],
}
pub type ggml_backend_event_t = *mut ggml_backend_event;
pub type ggml_backend_graph_plan_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_reg {
    _unused: [u8; 0],
}
pub type ggml_backend_reg_t = *mut ggml_backend_reg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_device {
    _unused: [u8; 0],
}
pub type ggml_backend_dev_t = *mut ggml_backend_device;
extern "C" {
    pub fn ggml_backend_buft_name(
        buft: ggml_backend_buffer_type_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_buft_alloc_buffer(
        buft: ggml_backend_buffer_type_t,
        size: usize,
    ) -> ggml_backend_buffer_t;
}
extern "C" {
    pub fn ggml_backend_buft_get_alignment(buft: ggml_backend_buffer_type_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_buft_get_max_size(buft: ggml_backend_buffer_type_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_buft_get_alloc_size(
        buft: ggml_backend_buffer_type_t,
        tensor: *mut ggml_tensor,
    ) -> usize;
}
extern "C" {
    pub fn ggml_backend_buft_is_host(buft: ggml_backend_buffer_type_t) -> bool;
}
extern "C" {
    pub fn ggml_backend_buft_get_device(buft: ggml_backend_buffer_type_t) -> ggml_backend_dev_t;
}
pub const GGML_BACKEND_BUFFER_USAGE_ANY: ggml_backend_buffer_usage = 0;
pub const GGML_BACKEND_BUFFER_USAGE_WEIGHTS: ggml_backend_buffer_usage = 1;
pub const GGML_BACKEND_BUFFER_USAGE_COMPUTE: ggml_backend_buffer_usage = 2;
pub type ggml_backend_buffer_usage = ::std::os::raw::c_int;
extern "C" {
    pub fn ggml_backend_buffer_name(buffer: ggml_backend_buffer_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_buffer_free(buffer: ggml_backend_buffer_t);
}
extern "C" {
    pub fn ggml_backend_buffer_get_base(
        buffer: ggml_backend_buffer_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ggml_backend_buffer_get_size(buffer: ggml_backend_buffer_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_buffer_init_tensor(
        buffer: ggml_backend_buffer_t,
        tensor: *mut ggml_tensor,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_buffer_get_alignment(buffer: ggml_backend_buffer_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_buffer_get_max_size(buffer: ggml_backend_buffer_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_buffer_get_alloc_size(
        buffer: ggml_backend_buffer_t,
        tensor: *mut ggml_tensor,
    ) -> usize;
}
extern "C" {
    pub fn ggml_backend_buffer_clear(buffer: ggml_backend_buffer_t, value: u8);
}
extern "C" {
    pub fn ggml_backend_buffer_is_host(buffer: ggml_backend_buffer_t) -> bool;
}
extern "C" {
    pub fn ggml_backend_buffer_set_usage(
        buffer: ggml_backend_buffer_t,
        usage: ggml_backend_buffer_usage,
    );
}
extern "C" {
    pub fn ggml_backend_buffer_get_usage(
        buffer: ggml_backend_buffer_t,
    ) -> ggml_backend_buffer_usage;
}
extern "C" {
    pub fn ggml_backend_buffer_get_type(
        buffer: ggml_backend_buffer_t,
    ) -> ggml_backend_buffer_type_t;
}
extern "C" {
    pub fn ggml_backend_buffer_reset(buffer: ggml_backend_buffer_t);
}
extern "C" {
    pub fn ggml_backend_tensor_copy(src: *mut ggml_tensor, dst: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_backend_guid(backend: ggml_backend_t) -> ggml_guid_t;
}
extern "C" {
    pub fn ggml_backend_name(backend: ggml_backend_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_free(backend: ggml_backend_t);
}
extern "C" {
    pub fn ggml_backend_get_default_buffer_type(
        backend: ggml_backend_t,
    ) -> ggml_backend_buffer_type_t;
}
extern "C" {
    pub fn ggml_backend_alloc_buffer(backend: ggml_backend_t, size: usize)
        -> ggml_backend_buffer_t;
}
extern "C" {
    pub fn ggml_backend_get_alignment(backend: ggml_backend_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_get_max_size(backend: ggml_backend_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_tensor_set_async(
        backend: ggml_backend_t,
        tensor: *mut ggml_tensor,
        data: *const ::std::os::raw::c_void,
        offset: usize,
        size: usize,
    );
}
extern "C" {
    pub fn ggml_backend_tensor_get_async(
        backend: ggml_backend_t,
        tensor: *const ggml_tensor,
        data: *mut ::std::os::raw::c_void,
        offset: usize,
        size: usize,
    );
}
extern "C" {
    pub fn ggml_backend_tensor_set(
        tensor: *mut ggml_tensor,
        data: *const ::std::os::raw::c_void,
        offset: usize,
        size: usize,
    );
}
extern "C" {
    pub fn ggml_backend_tensor_get(
        tensor: *const ggml_tensor,
        data: *mut ::std::os::raw::c_void,
        offset: usize,
        size: usize,
    );
}
extern "C" {
    pub fn ggml_backend_tensor_memset(
        tensor: *mut ggml_tensor,
        value: u8,
        offset: usize,
        size: usize,
    );
}
extern "C" {
    pub fn ggml_backend_synchronize(backend: ggml_backend_t);
}
extern "C" {
    pub fn ggml_backend_graph_plan_create(
        backend: ggml_backend_t,
        cgraph: *mut ggml_cgraph,
    ) -> ggml_backend_graph_plan_t;
}
extern "C" {
    pub fn ggml_backend_graph_plan_free(backend: ggml_backend_t, plan: ggml_backend_graph_plan_t);
}
extern "C" {
    pub fn ggml_backend_graph_plan_compute(
        backend: ggml_backend_t,
        plan: ggml_backend_graph_plan_t,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_graph_compute(
        backend: ggml_backend_t,
        cgraph: *mut ggml_cgraph,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_graph_compute_async(
        backend: ggml_backend_t,
        cgraph: *mut ggml_cgraph,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_supports_op(backend: ggml_backend_t, op: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_backend_supports_buft(
        backend: ggml_backend_t,
        buft: ggml_backend_buffer_type_t,
    ) -> bool;
}
extern "C" {
    pub fn ggml_backend_offload_op(backend: ggml_backend_t, op: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_backend_tensor_copy_async(
        backend_src: ggml_backend_t,
        backend_dst: ggml_backend_t,
        src: *mut ggml_tensor,
        dst: *mut ggml_tensor,
    );
}
extern "C" {
    pub fn ggml_backend_get_device(backend: ggml_backend_t) -> ggml_backend_dev_t;
}
extern "C" {
    pub fn ggml_backend_event_new(device: ggml_backend_dev_t) -> ggml_backend_event_t;
}
extern "C" {
    pub fn ggml_backend_event_free(event: ggml_backend_event_t);
}
extern "C" {
    pub fn ggml_backend_event_record(event: ggml_backend_event_t, backend: ggml_backend_t);
}
extern "C" {
    pub fn ggml_backend_event_synchronize(event: ggml_backend_event_t);
}
extern "C" {
    pub fn ggml_backend_event_wait(backend: ggml_backend_t, event: ggml_backend_event_t);
}
pub const GGML_BACKEND_DEVICE_TYPE_CPU: ggml_backend_dev_type = 0;
pub const GGML_BACKEND_DEVICE_TYPE_GPU: ggml_backend_dev_type = 1;
pub const GGML_BACKEND_DEVICE_TYPE_ACCEL: ggml_backend_dev_type = 2;
pub type ggml_backend_dev_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_backend_dev_caps {
    pub async_: bool,
    pub host_buffer: bool,
    pub buffer_from_host_ptr: bool,
    pub events: bool,
}
#[test]
fn bindgen_test_layout_ggml_backend_dev_caps() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_backend_dev_caps> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_backend_dev_caps>(),
        4usize,
        concat!("Size of: ", stringify!(ggml_backend_dev_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_backend_dev_caps>(),
        1usize,
        concat!("Alignment of ", stringify!(ggml_backend_dev_caps))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_caps),
            "::",
            stringify!(async_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_buffer) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_caps),
            "::",
            stringify!(host_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_from_host_ptr) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_caps),
            "::",
            stringify!(buffer_from_host_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_caps),
            "::",
            stringify!(events)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_backend_dev_props {
    pub name: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub memory_free: usize,
    pub memory_total: usize,
    pub type_: ggml_backend_dev_type,
    pub caps: ggml_backend_dev_caps,
}
#[test]
fn bindgen_test_layout_ggml_backend_dev_props() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_backend_dev_props> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_backend_dev_props>(),
        40usize,
        concat!("Size of: ", stringify!(ggml_backend_dev_props))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_backend_dev_props>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_backend_dev_props))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(memory_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_total) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(memory_total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caps) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(caps)
        )
    );
}
extern "C" {
    pub fn ggml_backend_dev_name(device: ggml_backend_dev_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_dev_description(
        device: ggml_backend_dev_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_dev_memory(device: ggml_backend_dev_t, free: *mut usize, total: *mut usize);
}
extern "C" {
    pub fn ggml_backend_dev_type(device: ggml_backend_dev_t) -> ggml_backend_dev_type;
}
extern "C" {
    pub fn ggml_backend_dev_get_props(
        device: ggml_backend_dev_t,
        props: *mut ggml_backend_dev_props,
    );
}
extern "C" {
    pub fn ggml_backend_dev_backend_reg(device: ggml_backend_dev_t) -> ggml_backend_reg_t;
}
extern "C" {
    pub fn ggml_backend_dev_init(
        device: ggml_backend_dev_t,
        params: *const ::std::os::raw::c_char,
    ) -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_dev_buffer_type(device: ggml_backend_dev_t) -> ggml_backend_buffer_type_t;
}
extern "C" {
    pub fn ggml_backend_dev_host_buffer_type(
        device: ggml_backend_dev_t,
    ) -> ggml_backend_buffer_type_t;
}
extern "C" {
    pub fn ggml_backend_dev_buffer_from_host_ptr(
        device: ggml_backend_dev_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        max_tensor_size: usize,
    ) -> ggml_backend_buffer_t;
}
extern "C" {
    pub fn ggml_backend_dev_supports_op(device: ggml_backend_dev_t, op: *const ggml_tensor)
        -> bool;
}
extern "C" {
    pub fn ggml_backend_dev_supports_buft(
        device: ggml_backend_dev_t,
        buft: ggml_backend_buffer_type_t,
    ) -> bool;
}
extern "C" {
    pub fn ggml_backend_dev_offload_op(device: ggml_backend_dev_t, op: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_backend_reg_name(reg: ggml_backend_reg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_reg_dev_count(reg: ggml_backend_reg_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_reg_dev_get(reg: ggml_backend_reg_t, index: usize) -> ggml_backend_dev_t;
}
extern "C" {
    pub fn ggml_backend_reg_get_proc_address(
        reg: ggml_backend_reg_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
pub type ggml_backend_split_buffer_type_t = ::std::option::Option<
    unsafe extern "C" fn(
        main_device: ::std::os::raw::c_int,
        tensor_split: *const f32,
    ) -> ggml_backend_buffer_type_t,
>;
pub type ggml_backend_set_n_threads_t = ::std::option::Option<
    unsafe extern "C" fn(backend: ggml_backend_t, n_threads: ::std::os::raw::c_int),
>;
pub type ggml_backend_dev_get_extra_bufts_t = ::std::option::Option<
    unsafe extern "C" fn(device: ggml_backend_dev_t) -> *mut ggml_backend_buffer_type_t,
>;
pub type ggml_backend_set_abort_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        backend: ggml_backend_t,
        abort_callback: ggml_abort_callback,
        abort_callback_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_backend_feature {
    pub name: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ggml_backend_feature() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_backend_feature> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_backend_feature>(),
        16usize,
        concat!("Size of: ", stringify!(ggml_backend_feature))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_backend_feature>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_backend_feature))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_feature),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_feature),
            "::",
            stringify!(value)
        )
    );
}
pub type ggml_backend_get_features_t = ::std::option::Option<
    unsafe extern "C" fn(reg: ggml_backend_reg_t) -> *mut ggml_backend_feature,
>;
extern "C" {
    pub fn ggml_backend_device_register(device: ggml_backend_dev_t);
}
extern "C" {
    pub fn ggml_backend_reg_count() -> usize;
}
extern "C" {
    pub fn ggml_backend_reg_get(index: usize) -> ggml_backend_reg_t;
}
extern "C" {
    pub fn ggml_backend_reg_by_name(name: *const ::std::os::raw::c_char) -> ggml_backend_reg_t;
}
extern "C" {
    pub fn ggml_backend_dev_count() -> usize;
}
extern "C" {
    pub fn ggml_backend_dev_get(index: usize) -> ggml_backend_dev_t;
}
extern "C" {
    pub fn ggml_backend_dev_by_name(name: *const ::std::os::raw::c_char) -> ggml_backend_dev_t;
}
extern "C" {
    pub fn ggml_backend_dev_by_type(type_: ggml_backend_dev_type) -> ggml_backend_dev_t;
}
extern "C" {
    pub fn ggml_backend_init_by_name(
        name: *const ::std::os::raw::c_char,
        params: *const ::std::os::raw::c_char,
    ) -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_init_by_type(
        type_: ggml_backend_dev_type,
        params: *const ::std::os::raw::c_char,
    ) -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_init_best() -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_load(path: *const ::std::os::raw::c_char) -> ggml_backend_reg_t;
}
extern "C" {
    pub fn ggml_backend_unload(reg: ggml_backend_reg_t);
}
extern "C" {
    pub fn ggml_backend_load_all();
}
extern "C" {
    pub fn ggml_backend_load_all_from_path(dir_path: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_sched {
    _unused: [u8; 0],
}
pub type ggml_backend_sched_t = *mut ggml_backend_sched;
pub type ggml_backend_sched_eval_callback = ::std::option::Option<
    unsafe extern "C" fn(
        t: *mut ggml_tensor,
        ask: bool,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn ggml_backend_sched_new(
        backends: *mut ggml_backend_t,
        bufts: *mut ggml_backend_buffer_type_t,
        n_backends: ::std::os::raw::c_int,
        graph_size: usize,
        parallel: bool,
    ) -> ggml_backend_sched_t;
}
extern "C" {
    pub fn ggml_backend_sched_free(sched: ggml_backend_sched_t);
}
extern "C" {
    pub fn ggml_backend_sched_reserve(
        sched: ggml_backend_sched_t,
        measure_graph: *mut ggml_cgraph,
    ) -> bool;
}
extern "C" {
    pub fn ggml_backend_sched_get_n_backends(sched: ggml_backend_sched_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_backend_sched_get_backend(
        sched: ggml_backend_sched_t,
        i: ::std::os::raw::c_int,
    ) -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_sched_get_n_splits(sched: ggml_backend_sched_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_backend_sched_get_n_copies(sched: ggml_backend_sched_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_backend_sched_get_buffer_size(
        sched: ggml_backend_sched_t,
        backend: ggml_backend_t,
    ) -> usize;
}
extern "C" {
    pub fn ggml_backend_sched_set_tensor_backend(
        sched: ggml_backend_sched_t,
        node: *mut ggml_tensor,
        backend: ggml_backend_t,
    );
}
extern "C" {
    pub fn ggml_backend_sched_get_tensor_backend(
        sched: ggml_backend_sched_t,
        node: *mut ggml_tensor,
    ) -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_sched_alloc_graph(
        sched: ggml_backend_sched_t,
        graph: *mut ggml_cgraph,
    ) -> bool;
}
extern "C" {
    pub fn ggml_backend_sched_graph_compute(
        sched: ggml_backend_sched_t,
        graph: *mut ggml_cgraph,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_sched_graph_compute_async(
        sched: ggml_backend_sched_t,
        graph: *mut ggml_cgraph,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_sched_synchronize(sched: ggml_backend_sched_t);
}
extern "C" {
    pub fn ggml_backend_sched_reset(sched: ggml_backend_sched_t);
}
extern "C" {
    pub fn ggml_backend_sched_set_eval_callback(
        sched: ggml_backend_sched_t,
        callback: ggml_backend_sched_eval_callback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_backend_graph_copy {
    pub buffer: ggml_backend_buffer_t,
    pub ctx_allocated: *mut ggml_context,
    pub ctx_unallocated: *mut ggml_context,
    pub graph: *mut ggml_cgraph,
}
#[test]
fn bindgen_test_layout_ggml_backend_graph_copy() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_backend_graph_copy> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_backend_graph_copy>(),
        32usize,
        concat!("Size of: ", stringify!(ggml_backend_graph_copy))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_backend_graph_copy>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_backend_graph_copy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_graph_copy),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_allocated) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_graph_copy),
            "::",
            stringify!(ctx_allocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_unallocated) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_graph_copy),
            "::",
            stringify!(ctx_unallocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_graph_copy),
            "::",
            stringify!(graph)
        )
    );
}
extern "C" {
    pub fn ggml_backend_graph_copy(
        backend: ggml_backend_t,
        graph: *mut ggml_cgraph,
    ) -> ggml_backend_graph_copy;
}
extern "C" {
    pub fn ggml_backend_graph_copy_free(copy: ggml_backend_graph_copy);
}
pub type ggml_backend_eval_callback = ::std::option::Option<
    unsafe extern "C" fn(
        node_index: ::std::os::raw::c_int,
        t1: *mut ggml_tensor,
        t2: *mut ggml_tensor,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn ggml_backend_compare_graph_backend(
        backend1: ggml_backend_t,
        backend2: ggml_backend_t,
        graph: *mut ggml_cgraph,
        callback: ggml_backend_eval_callback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn ggml_backend_tensor_alloc(
        buffer: ggml_backend_buffer_t,
        tensor: *mut ggml_tensor,
        addr: *mut ::std::os::raw::c_void,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_view_init(tensor: *mut ggml_tensor) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_cpu_buffer_from_ptr(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ggml_backend_buffer_t;
}
extern "C" {
    pub fn ggml_backend_cpu_buffer_type() -> ggml_backend_buffer_type_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_cplan {
    pub work_size: usize,
    pub work_data: *mut u8,
    pub n_threads: ::std::os::raw::c_int,
    pub threadpool: *mut ggml_threadpool,
    pub abort_callback: ggml_abort_callback,
    pub abort_callback_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ggml_cplan() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_cplan> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_cplan>(),
        48usize,
        concat!("Size of: ", stringify!(ggml_cplan))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_cplan>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_cplan))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).work_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(work_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).work_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(work_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_threads) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(n_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threadpool) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(threadpool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abort_callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(abort_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abort_callback_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(abort_callback_data)
        )
    );
}
pub const GGML_NUMA_STRATEGY_DISABLED: ggml_numa_strategy = 0;
pub const GGML_NUMA_STRATEGY_DISTRIBUTE: ggml_numa_strategy = 1;
pub const GGML_NUMA_STRATEGY_ISOLATE: ggml_numa_strategy = 2;
pub const GGML_NUMA_STRATEGY_NUMACTL: ggml_numa_strategy = 3;
pub const GGML_NUMA_STRATEGY_MIRROR: ggml_numa_strategy = 4;
pub const GGML_NUMA_STRATEGY_COUNT: ggml_numa_strategy = 5;
pub type ggml_numa_strategy = ::std::os::raw::c_int;
extern "C" {
    pub fn ggml_numa_init(numa: ggml_numa_strategy);
}
extern "C" {
    pub fn ggml_is_numa() -> bool;
}
extern "C" {
    pub fn ggml_new_i32(ctx: *mut ggml_context, value: i32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_f32(ctx: *mut ggml_context, value: f32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_i32(tensor: *mut ggml_tensor, value: i32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_f32(tensor: *mut ggml_tensor, value: f32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_i32_1d(tensor: *const ggml_tensor, i: ::std::os::raw::c_int) -> i32;
}
extern "C" {
    pub fn ggml_set_i32_1d(tensor: *const ggml_tensor, i: ::std::os::raw::c_int, value: i32);
}
extern "C" {
    pub fn ggml_get_i32_nd(
        tensor: *const ggml_tensor,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        i3: ::std::os::raw::c_int,
    ) -> i32;
}
extern "C" {
    pub fn ggml_set_i32_nd(
        tensor: *const ggml_tensor,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        i3: ::std::os::raw::c_int,
        value: i32,
    );
}
extern "C" {
    pub fn ggml_get_f32_1d(tensor: *const ggml_tensor, i: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ggml_set_f32_1d(tensor: *const ggml_tensor, i: ::std::os::raw::c_int, value: f32);
}
extern "C" {
    pub fn ggml_get_f32_nd(
        tensor: *const ggml_tensor,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        i3: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    pub fn ggml_set_f32_nd(
        tensor: *const ggml_tensor,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        i3: ::std::os::raw::c_int,
        value: f32,
    );
}
extern "C" {
    pub fn ggml_threadpool_new(params: *mut ggml_threadpool_params) -> *mut ggml_threadpool;
}
extern "C" {
    pub fn ggml_threadpool_free(threadpool: *mut ggml_threadpool);
}
extern "C" {
    pub fn ggml_threadpool_get_n_threads(threadpool: *mut ggml_threadpool)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_threadpool_pause(threadpool: *mut ggml_threadpool);
}
extern "C" {
    pub fn ggml_threadpool_resume(threadpool: *mut ggml_threadpool);
}
extern "C" {
    pub fn ggml_graph_plan(
        cgraph: *const ggml_cgraph,
        n_threads: ::std::os::raw::c_int,
        threadpool: *mut ggml_threadpool,
    ) -> ggml_cplan;
}
extern "C" {
    pub fn ggml_graph_compute(cgraph: *mut ggml_cgraph, cplan: *mut ggml_cplan) -> ggml_status;
}
extern "C" {
    pub fn ggml_graph_compute_with_ctx(
        ctx: *mut ggml_context,
        cgraph: *mut ggml_cgraph,
        n_threads: ::std::os::raw::c_int,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_cpu_has_sse3() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_ssse3() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx_vnni() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx2() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_bmi2() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_f16c() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_fma() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx512() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx512_vbmi() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx512_vnni() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx512_bf16() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_amx_int8() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_neon() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_arm_fma() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_fp16_va() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_dotprod() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_matmul_int8() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_sve() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_get_sve_cnt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_sme() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_riscv_v() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_vsx() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_vxe() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_wasm_simd() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_llamafile() -> ::std::os::raw::c_int;
}
pub type ggml_vec_dot_t = ::std::option::Option<
    unsafe extern "C" fn(
        n: ::std::os::raw::c_int,
        s: *mut f32,
        bs: usize,
        x: *const ::std::os::raw::c_void,
        bx: usize,
        y: *const ::std::os::raw::c_void,
        by: usize,
        nrc: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_type_traits_cpu {
    pub from_float: ggml_from_float_t,
    pub vec_dot: ggml_vec_dot_t,
    pub vec_dot_type: ggml_type,
    pub nrows: i64,
}
#[test]
fn bindgen_test_layout_ggml_type_traits_cpu() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_type_traits_cpu> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_type_traits_cpu>(),
        32usize,
        concat!("Size of: ", stringify!(ggml_type_traits_cpu))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_type_traits_cpu>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_type_traits_cpu))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits_cpu),
            "::",
            stringify!(from_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vec_dot) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits_cpu),
            "::",
            stringify!(vec_dot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vec_dot_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits_cpu),
            "::",
            stringify!(vec_dot_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrows) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits_cpu),
            "::",
            stringify!(nrows)
        )
    );
}
extern "C" {
    pub fn ggml_get_type_traits_cpu(type_: ggml_type) -> *const ggml_type_traits_cpu;
}
extern "C" {
    pub fn ggml_cpu_init();
}
extern "C" {
    pub fn ggml_backend_cpu_init() -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_is_cpu(backend: ggml_backend_t) -> bool;
}
extern "C" {
    pub fn ggml_backend_cpu_set_n_threads(
        backend_cpu: ggml_backend_t,
        n_threads: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ggml_backend_cpu_set_threadpool(
        backend_cpu: ggml_backend_t,
        threadpool: ggml_threadpool_t,
    );
}
extern "C" {
    pub fn ggml_backend_cpu_set_abort_callback(
        backend_cpu: ggml_backend_t,
        abort_callback: ggml_abort_callback,
        abort_callback_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ggml_backend_cpu_reg() -> ggml_backend_reg_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_vocab {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_model {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_kv_cache {
    _unused: [u8; 0],
}
pub type llama_pos = i32;
pub type llama_token = i32;
pub type llama_seq_id = i32;
pub const LLAMA_VOCAB_TYPE_NONE: llama_vocab_type = 0;
pub const LLAMA_VOCAB_TYPE_SPM: llama_vocab_type = 1;
pub const LLAMA_VOCAB_TYPE_BPE: llama_vocab_type = 2;
pub const LLAMA_VOCAB_TYPE_WPM: llama_vocab_type = 3;
pub const LLAMA_VOCAB_TYPE_UGM: llama_vocab_type = 4;
pub const LLAMA_VOCAB_TYPE_RWKV: llama_vocab_type = 5;
pub type llama_vocab_type = ::std::os::raw::c_int;
pub const LLAMA_VOCAB_PRE_TYPE_DEFAULT: llama_vocab_pre_type = 0;
pub const LLAMA_VOCAB_PRE_TYPE_LLAMA3: llama_vocab_pre_type = 1;
pub const LLAMA_VOCAB_PRE_TYPE_DEEPSEEK_LLM: llama_vocab_pre_type = 2;
pub const LLAMA_VOCAB_PRE_TYPE_DEEPSEEK_CODER: llama_vocab_pre_type = 3;
pub const LLAMA_VOCAB_PRE_TYPE_FALCON: llama_vocab_pre_type = 4;
pub const LLAMA_VOCAB_PRE_TYPE_MPT: llama_vocab_pre_type = 5;
pub const LLAMA_VOCAB_PRE_TYPE_STARCODER: llama_vocab_pre_type = 6;
pub const LLAMA_VOCAB_PRE_TYPE_GPT2: llama_vocab_pre_type = 7;
pub const LLAMA_VOCAB_PRE_TYPE_REFACT: llama_vocab_pre_type = 8;
pub const LLAMA_VOCAB_PRE_TYPE_COMMAND_R: llama_vocab_pre_type = 9;
pub const LLAMA_VOCAB_PRE_TYPE_STABLELM2: llama_vocab_pre_type = 10;
pub const LLAMA_VOCAB_PRE_TYPE_QWEN2: llama_vocab_pre_type = 11;
pub const LLAMA_VOCAB_PRE_TYPE_OLMO: llama_vocab_pre_type = 12;
pub const LLAMA_VOCAB_PRE_TYPE_DBRX: llama_vocab_pre_type = 13;
pub const LLAMA_VOCAB_PRE_TYPE_SMAUG: llama_vocab_pre_type = 14;
pub const LLAMA_VOCAB_PRE_TYPE_PORO: llama_vocab_pre_type = 15;
pub const LLAMA_VOCAB_PRE_TYPE_CHATGLM3: llama_vocab_pre_type = 16;
pub const LLAMA_VOCAB_PRE_TYPE_CHATGLM4: llama_vocab_pre_type = 17;
pub const LLAMA_VOCAB_PRE_TYPE_VIKING: llama_vocab_pre_type = 18;
pub const LLAMA_VOCAB_PRE_TYPE_JAIS: llama_vocab_pre_type = 19;
pub const LLAMA_VOCAB_PRE_TYPE_TEKKEN: llama_vocab_pre_type = 20;
pub const LLAMA_VOCAB_PRE_TYPE_SMOLLM: llama_vocab_pre_type = 21;
pub const LLAMA_VOCAB_PRE_TYPE_CODESHELL: llama_vocab_pre_type = 22;
pub const LLAMA_VOCAB_PRE_TYPE_BLOOM: llama_vocab_pre_type = 23;
pub const LLAMA_VOCAB_PRE_TYPE_GPT3_FINNISH: llama_vocab_pre_type = 24;
pub const LLAMA_VOCAB_PRE_TYPE_EXAONE: llama_vocab_pre_type = 25;
pub const LLAMA_VOCAB_PRE_TYPE_CHAMELEON: llama_vocab_pre_type = 26;
pub const LLAMA_VOCAB_PRE_TYPE_MINERVA: llama_vocab_pre_type = 27;
pub const LLAMA_VOCAB_PRE_TYPE_DEEPSEEK3_LLM: llama_vocab_pre_type = 28;
pub const LLAMA_VOCAB_PRE_TYPE_GPT4O: llama_vocab_pre_type = 29;
pub const LLAMA_VOCAB_PRE_TYPE_SUPERBPE: llama_vocab_pre_type = 30;
pub const LLAMA_VOCAB_PRE_TYPE_TRILLION: llama_vocab_pre_type = 31;
pub const LLAMA_VOCAB_PRE_TYPE_BAILINGMOE: llama_vocab_pre_type = 32;
pub const LLAMA_VOCAB_PRE_TYPE_LLAMA4: llama_vocab_pre_type = 33;
pub type llama_vocab_pre_type = ::std::os::raw::c_int;
pub const LLAMA_ROPE_TYPE_NONE: llama_rope_type = -1;
pub const LLAMA_ROPE_TYPE_NORM: llama_rope_type = 0;
pub const LLAMA_ROPE_TYPE_NEOX: llama_rope_type = 2;
pub const LLAMA_ROPE_TYPE_MROPE: llama_rope_type = 8;
pub const LLAMA_ROPE_TYPE_VISION: llama_rope_type = 24;
pub type llama_rope_type = ::std::os::raw::c_int;
pub const LLAMA_TOKEN_TYPE_UNDEFINED: llama_token_type = 0;
pub const LLAMA_TOKEN_TYPE_NORMAL: llama_token_type = 1;
pub const LLAMA_TOKEN_TYPE_UNKNOWN: llama_token_type = 2;
pub const LLAMA_TOKEN_TYPE_CONTROL: llama_token_type = 3;
pub const LLAMA_TOKEN_TYPE_USER_DEFINED: llama_token_type = 4;
pub const LLAMA_TOKEN_TYPE_UNUSED: llama_token_type = 5;
pub const LLAMA_TOKEN_TYPE_BYTE: llama_token_type = 6;
pub type llama_token_type = ::std::os::raw::c_int;
pub const LLAMA_TOKEN_ATTR_UNDEFINED: llama_token_attr = 0;
pub const LLAMA_TOKEN_ATTR_UNKNOWN: llama_token_attr = 1;
pub const LLAMA_TOKEN_ATTR_UNUSED: llama_token_attr = 2;
pub const LLAMA_TOKEN_ATTR_NORMAL: llama_token_attr = 4;
pub const LLAMA_TOKEN_ATTR_CONTROL: llama_token_attr = 8;
pub const LLAMA_TOKEN_ATTR_USER_DEFINED: llama_token_attr = 16;
pub const LLAMA_TOKEN_ATTR_BYTE: llama_token_attr = 32;
pub const LLAMA_TOKEN_ATTR_NORMALIZED: llama_token_attr = 64;
pub const LLAMA_TOKEN_ATTR_LSTRIP: llama_token_attr = 128;
pub const LLAMA_TOKEN_ATTR_RSTRIP: llama_token_attr = 256;
pub const LLAMA_TOKEN_ATTR_SINGLE_WORD: llama_token_attr = 512;
pub type llama_token_attr = ::std::os::raw::c_int;
pub const LLAMA_FTYPE_ALL_F32: llama_ftype = 0;
pub const LLAMA_FTYPE_MOSTLY_F16: llama_ftype = 1;
pub const LLAMA_FTYPE_MOSTLY_Q4_0: llama_ftype = 2;
pub const LLAMA_FTYPE_MOSTLY_Q4_1: llama_ftype = 3;
pub const LLAMA_FTYPE_MOSTLY_Q8_0: llama_ftype = 7;
pub const LLAMA_FTYPE_MOSTLY_Q5_0: llama_ftype = 8;
pub const LLAMA_FTYPE_MOSTLY_Q5_1: llama_ftype = 9;
pub const LLAMA_FTYPE_MOSTLY_Q2_K: llama_ftype = 10;
pub const LLAMA_FTYPE_MOSTLY_Q3_K_S: llama_ftype = 11;
pub const LLAMA_FTYPE_MOSTLY_Q3_K_M: llama_ftype = 12;
pub const LLAMA_FTYPE_MOSTLY_Q3_K_L: llama_ftype = 13;
pub const LLAMA_FTYPE_MOSTLY_Q4_K_S: llama_ftype = 14;
pub const LLAMA_FTYPE_MOSTLY_Q4_K_M: llama_ftype = 15;
pub const LLAMA_FTYPE_MOSTLY_Q5_K_S: llama_ftype = 16;
pub const LLAMA_FTYPE_MOSTLY_Q5_K_M: llama_ftype = 17;
pub const LLAMA_FTYPE_MOSTLY_Q6_K: llama_ftype = 18;
pub const LLAMA_FTYPE_MOSTLY_IQ2_XXS: llama_ftype = 19;
pub const LLAMA_FTYPE_MOSTLY_IQ2_XS: llama_ftype = 20;
pub const LLAMA_FTYPE_MOSTLY_Q2_K_S: llama_ftype = 21;
pub const LLAMA_FTYPE_MOSTLY_IQ3_XS: llama_ftype = 22;
pub const LLAMA_FTYPE_MOSTLY_IQ3_XXS: llama_ftype = 23;
pub const LLAMA_FTYPE_MOSTLY_IQ1_S: llama_ftype = 24;
pub const LLAMA_FTYPE_MOSTLY_IQ4_NL: llama_ftype = 25;
pub const LLAMA_FTYPE_MOSTLY_IQ3_S: llama_ftype = 26;
pub const LLAMA_FTYPE_MOSTLY_IQ3_M: llama_ftype = 27;
pub const LLAMA_FTYPE_MOSTLY_IQ2_S: llama_ftype = 28;
pub const LLAMA_FTYPE_MOSTLY_IQ2_M: llama_ftype = 29;
pub const LLAMA_FTYPE_MOSTLY_IQ4_XS: llama_ftype = 30;
pub const LLAMA_FTYPE_MOSTLY_IQ1_M: llama_ftype = 31;
pub const LLAMA_FTYPE_MOSTLY_BF16: llama_ftype = 32;
pub const LLAMA_FTYPE_MOSTLY_TQ1_0: llama_ftype = 36;
pub const LLAMA_FTYPE_MOSTLY_TQ2_0: llama_ftype = 37;
pub const LLAMA_FTYPE_GUESSED: llama_ftype = 1024;
pub type llama_ftype = ::std::os::raw::c_int;
pub const LLAMA_ROPE_SCALING_TYPE_UNSPECIFIED: llama_rope_scaling_type = -1;
pub const LLAMA_ROPE_SCALING_TYPE_NONE: llama_rope_scaling_type = 0;
pub const LLAMA_ROPE_SCALING_TYPE_LINEAR: llama_rope_scaling_type = 1;
pub const LLAMA_ROPE_SCALING_TYPE_YARN: llama_rope_scaling_type = 2;
pub const LLAMA_ROPE_SCALING_TYPE_LONGROPE: llama_rope_scaling_type = 3;
pub const LLAMA_ROPE_SCALING_TYPE_MAX_VALUE: llama_rope_scaling_type = 3;
pub type llama_rope_scaling_type = ::std::os::raw::c_int;
pub const LLAMA_POOLING_TYPE_UNSPECIFIED: llama_pooling_type = -1;
pub const LLAMA_POOLING_TYPE_NONE: llama_pooling_type = 0;
pub const LLAMA_POOLING_TYPE_MEAN: llama_pooling_type = 1;
pub const LLAMA_POOLING_TYPE_CLS: llama_pooling_type = 2;
pub const LLAMA_POOLING_TYPE_LAST: llama_pooling_type = 3;
pub const LLAMA_POOLING_TYPE_RANK: llama_pooling_type = 4;
pub type llama_pooling_type = ::std::os::raw::c_int;
pub const LLAMA_ATTENTION_TYPE_UNSPECIFIED: llama_attention_type = -1;
pub const LLAMA_ATTENTION_TYPE_CAUSAL: llama_attention_type = 0;
pub const LLAMA_ATTENTION_TYPE_NON_CAUSAL: llama_attention_type = 1;
pub type llama_attention_type = ::std::os::raw::c_int;
pub const LLAMA_SPLIT_MODE_NONE: llama_split_mode = 0;
pub const LLAMA_SPLIT_MODE_LAYER: llama_split_mode = 1;
pub const LLAMA_SPLIT_MODE_ROW: llama_split_mode = 2;
pub type llama_split_mode = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_token_data {
    pub id: llama_token,
    pub logit: f32,
    pub p: f32,
}
#[test]
fn bindgen_test_layout_llama_token_data() {
    const UNINIT: ::std::mem::MaybeUninit<llama_token_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_token_data>(),
        12usize,
        concat!("Size of: ", stringify!(llama_token_data))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_token_data>(),
        4usize,
        concat!("Alignment of ", stringify!(llama_token_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data),
            "::",
            stringify!(logit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data),
            "::",
            stringify!(p)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_token_data_array {
    pub data: *mut llama_token_data,
    pub size: usize,
    pub selected: i64,
    pub sorted: bool,
}
#[test]
fn bindgen_test_layout_llama_token_data_array() {
    const UNINIT: ::std::mem::MaybeUninit<llama_token_data_array> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_token_data_array>(),
        32usize,
        concat!("Size of: ", stringify!(llama_token_data_array))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_token_data_array>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_token_data_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data_array),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data_array),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selected) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data_array),
            "::",
            stringify!(selected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sorted) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data_array),
            "::",
            stringify!(sorted)
        )
    );
}
pub type llama_progress_callback = ::std::option::Option<
    unsafe extern "C" fn(progress: f32, user_data: *mut ::std::os::raw::c_void) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_batch {
    pub n_tokens: i32,
    pub token: *mut llama_token,
    pub embd: *mut f32,
    pub pos: *mut llama_pos,
    pub n_seq_id: *mut i32,
    pub seq_id: *mut *mut llama_seq_id,
    pub logits: *mut i8,
}
#[test]
fn bindgen_test_layout_llama_batch() {
    const UNINIT: ::std::mem::MaybeUninit<llama_batch> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_batch>(),
        56usize,
        concat!("Size of: ", stringify!(llama_batch))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_batch>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_batch))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_tokens) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(n_tokens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).embd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(embd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_seq_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(n_seq_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(seq_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logits) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(logits)
        )
    );
}
pub const LLAMA_KV_OVERRIDE_TYPE_INT: llama_model_kv_override_type = 0;
pub const LLAMA_KV_OVERRIDE_TYPE_FLOAT: llama_model_kv_override_type = 1;
pub const LLAMA_KV_OVERRIDE_TYPE_BOOL: llama_model_kv_override_type = 2;
pub const LLAMA_KV_OVERRIDE_TYPE_STR: llama_model_kv_override_type = 3;
pub type llama_model_kv_override_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llama_model_kv_override {
    pub tag: llama_model_kv_override_type,
    pub key: [::std::os::raw::c_char; 128usize],
    pub __bindgen_anon_1: llama_model_kv_override__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union llama_model_kv_override__bindgen_ty_1 {
    pub val_i64: i64,
    pub val_f64: f64,
    pub val_bool: bool,
    pub val_str: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_llama_model_kv_override__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<llama_model_kv_override__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_model_kv_override__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(llama_model_kv_override__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llama_model_kv_override__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llama_model_kv_override__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_i64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override__bindgen_ty_1),
            "::",
            stringify!(val_i64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_f64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override__bindgen_ty_1),
            "::",
            stringify!(val_f64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_bool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override__bindgen_ty_1),
            "::",
            stringify!(val_bool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_str) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override__bindgen_ty_1),
            "::",
            stringify!(val_str)
        )
    );
}
#[test]
fn bindgen_test_layout_llama_model_kv_override() {
    const UNINIT: ::std::mem::MaybeUninit<llama_model_kv_override> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_model_kv_override>(),
        264usize,
        concat!("Size of: ", stringify!(llama_model_kv_override))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_model_kv_override>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_model_kv_override))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_model_tensor_buft_override {
    pub pattern: *const ::std::os::raw::c_char,
    pub buft: ggml_backend_buffer_type_t,
}
#[test]
fn bindgen_test_layout_llama_model_tensor_buft_override() {
    const UNINIT: ::std::mem::MaybeUninit<llama_model_tensor_buft_override> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_model_tensor_buft_override>(),
        16usize,
        concat!("Size of: ", stringify!(llama_model_tensor_buft_override))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_model_tensor_buft_override>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llama_model_tensor_buft_override)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_tensor_buft_override),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buft) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_tensor_buft_override),
            "::",
            stringify!(buft)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_model_params {
    pub devices: *mut ggml_backend_dev_t,
    pub tensor_buft_overrides: *const llama_model_tensor_buft_override,
    pub n_gpu_layers: i32,
    pub split_mode: llama_split_mode,
    pub main_gpu: i32,
    pub tensor_split: *const f32,
    pub progress_callback: llama_progress_callback,
    pub progress_callback_user_data: *mut ::std::os::raw::c_void,
    pub kv_overrides: *const llama_model_kv_override,
    pub vocab_only: bool,
    pub use_mmap: bool,
    pub use_mlock: bool,
    pub check_tensors: bool,
}
#[test]
fn bindgen_test_layout_llama_model_params() {
    const UNINIT: ::std::mem::MaybeUninit<llama_model_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_model_params>(),
        72usize,
        concat!("Size of: ", stringify!(llama_model_params))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_model_params>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_model_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(devices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tensor_buft_overrides) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(tensor_buft_overrides)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_gpu_layers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(n_gpu_layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).split_mode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(split_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).main_gpu) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(main_gpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tensor_split) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(tensor_split)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progress_callback) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(progress_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progress_callback_user_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(progress_callback_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kv_overrides) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(kv_overrides)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vocab_only) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(vocab_only)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_mmap) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(use_mmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_mlock) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(use_mlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check_tensors) as usize - ptr as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(check_tensors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_context_params {
    pub n_ctx: u32,
    pub n_batch: u32,
    pub n_ubatch: u32,
    pub n_seq_max: u32,
    pub n_threads: i32,
    pub n_threads_batch: i32,
    pub rope_scaling_type: llama_rope_scaling_type,
    pub pooling_type: llama_pooling_type,
    pub attention_type: llama_attention_type,
    pub rope_freq_base: f32,
    pub rope_freq_scale: f32,
    pub yarn_ext_factor: f32,
    pub yarn_attn_factor: f32,
    pub yarn_beta_fast: f32,
    pub yarn_beta_slow: f32,
    pub yarn_orig_ctx: u32,
    pub defrag_thold: f32,
    pub cb_eval: ggml_backend_sched_eval_callback,
    pub cb_eval_user_data: *mut ::std::os::raw::c_void,
    pub type_k: ggml_type,
    pub type_v: ggml_type,
    pub logits_all: bool,
    pub embeddings: bool,
    pub offload_kqv: bool,
    pub flash_attn: bool,
    pub no_perf: bool,
    pub abort_callback: ggml_abort_callback,
    pub abort_callback_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_llama_context_params() {
    const UNINIT: ::std::mem::MaybeUninit<llama_context_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_context_params>(),
        120usize,
        concat!("Size of: ", stringify!(llama_context_params))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_context_params>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_context_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_batch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_batch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_ubatch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_ubatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_seq_max) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_seq_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_threads) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_threads_batch) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_threads_batch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rope_scaling_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(rope_scaling_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pooling_type) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(pooling_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attention_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(attention_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rope_freq_base) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(rope_freq_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rope_freq_scale) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(rope_freq_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yarn_ext_factor) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(yarn_ext_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yarn_attn_factor) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(yarn_attn_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yarn_beta_fast) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(yarn_beta_fast)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yarn_beta_slow) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(yarn_beta_slow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yarn_orig_ctx) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(yarn_orig_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defrag_thold) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(defrag_thold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_eval) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(cb_eval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_eval_user_data) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(cb_eval_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_k) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(type_k)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_v) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(type_v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logits_all) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(logits_all)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).embeddings) as usize - ptr as usize },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(embeddings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offload_kqv) as usize - ptr as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(offload_kqv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flash_attn) as usize - ptr as usize },
        99usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(flash_attn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_perf) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(no_perf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abort_callback) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(abort_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abort_callback_data) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(abort_callback_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_model_quantize_params {
    pub nthread: i32,
    pub ftype: llama_ftype,
    pub output_tensor_type: ggml_type,
    pub token_embedding_type: ggml_type,
    pub allow_requantize: bool,
    pub quantize_output_tensor: bool,
    pub only_copy: bool,
    pub pure_: bool,
    pub keep_split: bool,
    pub imatrix: *mut ::std::os::raw::c_void,
    pub kv_overrides: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_llama_model_quantize_params() {
    const UNINIT: ::std::mem::MaybeUninit<llama_model_quantize_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_model_quantize_params>(),
        40usize,
        concat!("Size of: ", stringify!(llama_model_quantize_params))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_model_quantize_params>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_model_quantize_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nthread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(nthread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ftype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(ftype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_tensor_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(output_tensor_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token_embedding_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(token_embedding_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_requantize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(allow_requantize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quantize_output_tensor) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(quantize_output_tensor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).only_copy) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(only_copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pure_) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(pure_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_split) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(keep_split)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imatrix) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(imatrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kv_overrides) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(kv_overrides)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_logit_bias {
    pub token: llama_token,
    pub bias: f32,
}
#[test]
fn bindgen_test_layout_llama_logit_bias() {
    const UNINIT: ::std::mem::MaybeUninit<llama_logit_bias> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_logit_bias>(),
        8usize,
        concat!("Size of: ", stringify!(llama_logit_bias))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_logit_bias>(),
        4usize,
        concat!("Alignment of ", stringify!(llama_logit_bias))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_logit_bias),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bias) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_logit_bias),
            "::",
            stringify!(bias)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_sampler_chain_params {
    pub no_perf: bool,
}
#[test]
fn bindgen_test_layout_llama_sampler_chain_params() {
    const UNINIT: ::std::mem::MaybeUninit<llama_sampler_chain_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_sampler_chain_params>(),
        1usize,
        concat!("Size of: ", stringify!(llama_sampler_chain_params))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_sampler_chain_params>(),
        1usize,
        concat!("Alignment of ", stringify!(llama_sampler_chain_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_perf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_chain_params),
            "::",
            stringify!(no_perf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_chat_message {
    pub role: *const ::std::os::raw::c_char,
    pub content: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_llama_chat_message() {
    const UNINIT: ::std::mem::MaybeUninit<llama_chat_message> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_chat_message>(),
        16usize,
        concat!("Size of: ", stringify!(llama_chat_message))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_chat_message>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_chat_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).role) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_chat_message),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_chat_message),
            "::",
            stringify!(content)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_adapter_lora {
    _unused: [u8; 0],
}
extern "C" {
    pub fn llama_model_default_params() -> llama_model_params;
}
extern "C" {
    pub fn llama_context_default_params() -> llama_context_params;
}
extern "C" {
    pub fn llama_sampler_chain_default_params() -> llama_sampler_chain_params;
}
extern "C" {
    pub fn llama_model_quantize_default_params() -> llama_model_quantize_params;
}
extern "C" {
    pub fn llama_backend_init();
}
extern "C" {
    pub fn llama_backend_free();
}
extern "C" {
    pub fn llama_numa_init(numa: ggml_numa_strategy);
}
extern "C" {
    pub fn llama_attach_threadpool(
        ctx: *mut llama_context,
        threadpool: ggml_threadpool_t,
        threadpool_batch: ggml_threadpool_t,
    );
}
extern "C" {
    pub fn llama_detach_threadpool(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_load_model_from_file(
        path_model: *const ::std::os::raw::c_char,
        params: llama_model_params,
    ) -> *mut llama_model;
}
extern "C" {
    pub fn llama_model_load_from_file(
        path_model: *const ::std::os::raw::c_char,
        params: llama_model_params,
    ) -> *mut llama_model;
}
extern "C" {
    pub fn llama_model_load_from_splits(
        paths: *mut *const ::std::os::raw::c_char,
        n_paths: usize,
        params: llama_model_params,
    ) -> *mut llama_model;
}
extern "C" {
    pub fn llama_free_model(model: *mut llama_model);
}
extern "C" {
    pub fn llama_model_free(model: *mut llama_model);
}
extern "C" {
    pub fn llama_init_from_model(
        model: *mut llama_model,
        params: llama_context_params,
    ) -> *mut llama_context;
}
extern "C" {
    pub fn llama_new_context_with_model(
        model: *mut llama_model,
        params: llama_context_params,
    ) -> *mut llama_context;
}
extern "C" {
    pub fn llama_free(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_time_us() -> i64;
}
extern "C" {
    pub fn llama_max_devices() -> usize;
}
extern "C" {
    pub fn llama_supports_mmap() -> bool;
}
extern "C" {
    pub fn llama_supports_mlock() -> bool;
}
extern "C" {
    pub fn llama_supports_gpu_offload() -> bool;
}
extern "C" {
    pub fn llama_supports_rpc() -> bool;
}
extern "C" {
    pub fn llama_n_ctx(ctx: *const llama_context) -> u32;
}
extern "C" {
    pub fn llama_n_batch(ctx: *const llama_context) -> u32;
}
extern "C" {
    pub fn llama_n_ubatch(ctx: *const llama_context) -> u32;
}
extern "C" {
    pub fn llama_n_seq_max(ctx: *const llama_context) -> u32;
}
extern "C" {
    pub fn llama_n_ctx_train(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_n_embd(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_n_layer(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_n_head(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_n_vocab(vocab: *const llama_vocab) -> i32;
}
extern "C" {
    pub fn llama_get_model(ctx: *const llama_context) -> *const llama_model;
}
extern "C" {
    pub fn llama_get_kv_self(ctx: *mut llama_context) -> *mut llama_kv_cache;
}
extern "C" {
    pub fn llama_pooling_type(ctx: *const llama_context) -> llama_pooling_type;
}
extern "C" {
    pub fn llama_model_get_vocab(model: *const llama_model) -> *const llama_vocab;
}
extern "C" {
    pub fn llama_model_rope_type(model: *const llama_model) -> llama_rope_type;
}
extern "C" {
    pub fn llama_model_n_ctx_train(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_n_embd(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_n_layer(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_n_head(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_n_head_kv(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_rope_freq_scale_train(model: *const llama_model) -> f32;
}
extern "C" {
    pub fn llama_vocab_type(vocab: *const llama_vocab) -> llama_vocab_type;
}
extern "C" {
    pub fn llama_vocab_n_tokens(vocab: *const llama_vocab) -> i32;
}
extern "C" {
    pub fn llama_model_meta_val_str(
        model: *const llama_model,
        key: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> i32;
}
extern "C" {
    pub fn llama_model_meta_count(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_meta_key_by_index(
        model: *const llama_model,
        i: i32,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> i32;
}
extern "C" {
    pub fn llama_model_meta_val_str_by_index(
        model: *const llama_model,
        i: i32,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> i32;
}
extern "C" {
    pub fn llama_model_desc(
        model: *const llama_model,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> i32;
}
extern "C" {
    pub fn llama_model_size(model: *const llama_model) -> u64;
}
extern "C" {
    pub fn llama_model_chat_template(
        model: *const llama_model,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_model_n_params(model: *const llama_model) -> u64;
}
extern "C" {
    pub fn llama_model_has_encoder(model: *const llama_model) -> bool;
}
extern "C" {
    pub fn llama_model_has_decoder(model: *const llama_model) -> bool;
}
extern "C" {
    pub fn llama_model_decoder_start_token(model: *const llama_model) -> llama_token;
}
extern "C" {
    pub fn llama_model_is_recurrent(model: *const llama_model) -> bool;
}
extern "C" {
    pub fn llama_model_quantize(
        fname_inp: *const ::std::os::raw::c_char,
        fname_out: *const ::std::os::raw::c_char,
        params: *const llama_model_quantize_params,
    ) -> u32;
}
extern "C" {
    pub fn llama_adapter_lora_init(
        model: *mut llama_model,
        path_lora: *const ::std::os::raw::c_char,
    ) -> *mut llama_adapter_lora;
}
extern "C" {
    pub fn llama_adapter_lora_free(adapter: *mut llama_adapter_lora);
}
extern "C" {
    pub fn llama_set_adapter_lora(
        ctx: *mut llama_context,
        adapter: *mut llama_adapter_lora,
        scale: f32,
    ) -> i32;
}
extern "C" {
    pub fn llama_rm_adapter_lora(ctx: *mut llama_context, adapter: *mut llama_adapter_lora) -> i32;
}
extern "C" {
    pub fn llama_clear_adapter_lora(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_apply_adapter_cvec(
        ctx: *mut llama_context,
        data: *const f32,
        len: usize,
        n_embd: i32,
        il_start: i32,
        il_end: i32,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_kv_cache_view_cell {
    pub pos: llama_pos,
}
#[test]
fn bindgen_test_layout_llama_kv_cache_view_cell() {
    const UNINIT: ::std::mem::MaybeUninit<llama_kv_cache_view_cell> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_kv_cache_view_cell>(),
        4usize,
        concat!("Size of: ", stringify!(llama_kv_cache_view_cell))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_kv_cache_view_cell>(),
        4usize,
        concat!("Alignment of ", stringify!(llama_kv_cache_view_cell))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_kv_cache_view_cell),
            "::",
            stringify!(pos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_kv_cache_view {
    pub n_cells: i32,
    pub n_seq_max: i32,
    pub token_count: i32,
    pub used_cells: i32,
    pub max_contiguous: i32,
    pub max_contiguous_idx: i32,
    pub cells: *mut llama_kv_cache_view_cell,
    pub cells_sequences: *mut llama_seq_id,
}
#[test]
fn bindgen_test_layout_llama_kv_cache_view() {
    const UNINIT: ::std::mem::MaybeUninit<llama_kv_cache_view> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_kv_cache_view>(),
        40usize,
        concat!("Size of: ", stringify!(llama_kv_cache_view))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_kv_cache_view>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_kv_cache_view))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_cells) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_kv_cache_view),
            "::",
            stringify!(n_cells)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_seq_max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_kv_cache_view),
            "::",
            stringify!(n_seq_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_kv_cache_view),
            "::",
            stringify!(token_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).used_cells) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_kv_cache_view),
            "::",
            stringify!(used_cells)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_contiguous) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_kv_cache_view),
            "::",
            stringify!(max_contiguous)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_contiguous_idx) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_kv_cache_view),
            "::",
            stringify!(max_contiguous_idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cells) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_kv_cache_view),
            "::",
            stringify!(cells)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cells_sequences) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_kv_cache_view),
            "::",
            stringify!(cells_sequences)
        )
    );
}
extern "C" {
    pub fn llama_kv_cache_view_init(
        ctx: *const llama_context,
        n_seq_max: i32,
    ) -> llama_kv_cache_view;
}
extern "C" {
    pub fn llama_kv_cache_view_free(view: *mut llama_kv_cache_view);
}
extern "C" {
    pub fn llama_kv_cache_view_update(ctx: *const llama_context, view: *mut llama_kv_cache_view);
}
extern "C" {
    pub fn llama_kv_self_n_tokens(ctx: *const llama_context) -> i32;
}
extern "C" {
    pub fn llama_get_kv_cache_token_count(ctx: *const llama_context) -> i32;
}
extern "C" {
    pub fn llama_kv_self_used_cells(ctx: *const llama_context) -> i32;
}
extern "C" {
    pub fn llama_get_kv_cache_used_cells(ctx: *const llama_context) -> i32;
}
extern "C" {
    pub fn llama_kv_self_clear(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_kv_self_seq_rm(
        ctx: *mut llama_context,
        seq_id: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
    ) -> bool;
}
extern "C" {
    pub fn llama_kv_self_seq_cp(
        ctx: *mut llama_context,
        seq_id_src: llama_seq_id,
        seq_id_dst: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
    );
}
extern "C" {
    pub fn llama_kv_self_seq_keep(ctx: *mut llama_context, seq_id: llama_seq_id);
}
extern "C" {
    pub fn llama_kv_self_seq_add(
        ctx: *mut llama_context,
        seq_id: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
        delta: llama_pos,
    );
}
extern "C" {
    pub fn llama_kv_self_seq_div(
        ctx: *mut llama_context,
        seq_id: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
        d: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn llama_kv_self_seq_pos_max(ctx: *mut llama_context, seq_id: llama_seq_id) -> llama_pos;
}
extern "C" {
    pub fn llama_kv_self_defrag(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_kv_self_can_shift(ctx: *const llama_context) -> bool;
}
extern "C" {
    pub fn llama_kv_self_update(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_kv_cache_clear(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_kv_cache_seq_rm(
        ctx: *mut llama_context,
        seq_id: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
    ) -> bool;
}
extern "C" {
    pub fn llama_kv_cache_seq_cp(
        ctx: *mut llama_context,
        seq_id_src: llama_seq_id,
        seq_id_dst: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
    );
}
extern "C" {
    pub fn llama_kv_cache_seq_keep(ctx: *mut llama_context, seq_id: llama_seq_id);
}
extern "C" {
    pub fn llama_kv_cache_seq_add(
        ctx: *mut llama_context,
        seq_id: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
        delta: llama_pos,
    );
}
extern "C" {
    pub fn llama_kv_cache_seq_div(
        ctx: *mut llama_context,
        seq_id: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
        d: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn llama_kv_cache_seq_pos_max(ctx: *mut llama_context, seq_id: llama_seq_id) -> llama_pos;
}
extern "C" {
    pub fn llama_kv_cache_defrag(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_kv_cache_can_shift(ctx: *const llama_context) -> bool;
}
extern "C" {
    pub fn llama_kv_cache_update(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_state_get_size(ctx: *mut llama_context) -> usize;
}
extern "C" {
    pub fn llama_get_state_size(ctx: *mut llama_context) -> usize;
}
extern "C" {
    pub fn llama_state_get_data(ctx: *mut llama_context, dst: *mut u8, size: usize) -> usize;
}
extern "C" {
    pub fn llama_copy_state_data(ctx: *mut llama_context, dst: *mut u8) -> usize;
}
extern "C" {
    pub fn llama_state_set_data(ctx: *mut llama_context, src: *const u8, size: usize) -> usize;
}
extern "C" {
    pub fn llama_set_state_data(ctx: *mut llama_context, src: *const u8) -> usize;
}
extern "C" {
    pub fn llama_state_load_file(
        ctx: *mut llama_context,
        path_session: *const ::std::os::raw::c_char,
        tokens_out: *mut llama_token,
        n_token_capacity: usize,
        n_token_count_out: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn llama_load_session_file(
        ctx: *mut llama_context,
        path_session: *const ::std::os::raw::c_char,
        tokens_out: *mut llama_token,
        n_token_capacity: usize,
        n_token_count_out: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn llama_state_save_file(
        ctx: *mut llama_context,
        path_session: *const ::std::os::raw::c_char,
        tokens: *const llama_token,
        n_token_count: usize,
    ) -> bool;
}
extern "C" {
    pub fn llama_save_session_file(
        ctx: *mut llama_context,
        path_session: *const ::std::os::raw::c_char,
        tokens: *const llama_token,
        n_token_count: usize,
    ) -> bool;
}
extern "C" {
    pub fn llama_state_seq_get_size(ctx: *mut llama_context, seq_id: llama_seq_id) -> usize;
}
extern "C" {
    pub fn llama_state_seq_get_data(
        ctx: *mut llama_context,
        dst: *mut u8,
        size: usize,
        seq_id: llama_seq_id,
    ) -> usize;
}
extern "C" {
    pub fn llama_state_seq_set_data(
        ctx: *mut llama_context,
        src: *const u8,
        size: usize,
        dest_seq_id: llama_seq_id,
    ) -> usize;
}
extern "C" {
    pub fn llama_state_seq_save_file(
        ctx: *mut llama_context,
        filepath: *const ::std::os::raw::c_char,
        seq_id: llama_seq_id,
        tokens: *const llama_token,
        n_token_count: usize,
    ) -> usize;
}
extern "C" {
    pub fn llama_state_seq_load_file(
        ctx: *mut llama_context,
        filepath: *const ::std::os::raw::c_char,
        dest_seq_id: llama_seq_id,
        tokens_out: *mut llama_token,
        n_token_capacity: usize,
        n_token_count_out: *mut usize,
    ) -> usize;
}
extern "C" {
    pub fn llama_batch_get_one(tokens: *mut llama_token, n_tokens: i32) -> llama_batch;
}
extern "C" {
    pub fn llama_batch_init(n_tokens: i32, embd: i32, n_seq_max: i32) -> llama_batch;
}
extern "C" {
    pub fn llama_batch_free(batch: llama_batch);
}
extern "C" {
    pub fn llama_encode(ctx: *mut llama_context, batch: llama_batch) -> i32;
}
extern "C" {
    pub fn llama_decode(ctx: *mut llama_context, batch: llama_batch) -> i32;
}
extern "C" {
    pub fn llama_set_n_threads(ctx: *mut llama_context, n_threads: i32, n_threads_batch: i32);
}
extern "C" {
    pub fn llama_n_threads(ctx: *mut llama_context) -> i32;
}
extern "C" {
    pub fn llama_n_threads_batch(ctx: *mut llama_context) -> i32;
}
extern "C" {
    pub fn llama_set_embeddings(ctx: *mut llama_context, embeddings: bool);
}
extern "C" {
    pub fn llama_set_causal_attn(ctx: *mut llama_context, causal_attn: bool);
}
extern "C" {
    pub fn llama_set_warmup(ctx: *mut llama_context, warmup: bool);
}
extern "C" {
    pub fn llama_set_abort_callback(
        ctx: *mut llama_context,
        abort_callback: ggml_abort_callback,
        abort_callback_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn llama_synchronize(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_get_logits(ctx: *mut llama_context) -> *mut f32;
}
extern "C" {
    pub fn llama_get_logits_ith(ctx: *mut llama_context, i: i32) -> *mut f32;
}
extern "C" {
    pub fn llama_get_embeddings(ctx: *mut llama_context) -> *mut f32;
}
extern "C" {
    pub fn llama_get_embeddings_ith(ctx: *mut llama_context, i: i32) -> *mut f32;
}
extern "C" {
    pub fn llama_get_embeddings_seq(ctx: *mut llama_context, seq_id: llama_seq_id) -> *mut f32;
}
extern "C" {
    pub fn llama_vocab_get_text(
        vocab: *const llama_vocab,
        token: llama_token,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_vocab_get_score(vocab: *const llama_vocab, token: llama_token) -> f32;
}
extern "C" {
    pub fn llama_vocab_get_attr(vocab: *const llama_vocab, token: llama_token) -> llama_token_attr;
}
extern "C" {
    pub fn llama_vocab_is_eog(vocab: *const llama_vocab, token: llama_token) -> bool;
}
extern "C" {
    pub fn llama_vocab_is_control(vocab: *const llama_vocab, token: llama_token) -> bool;
}
extern "C" {
    pub fn llama_vocab_bos(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_eos(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_eot(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_sep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_nl(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_pad(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_get_add_bos(vocab: *const llama_vocab) -> bool;
}
extern "C" {
    pub fn llama_vocab_get_add_eos(vocab: *const llama_vocab) -> bool;
}
extern "C" {
    pub fn llama_vocab_fim_pre(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_fim_suf(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_fim_mid(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_fim_pad(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_fim_rep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_fim_sep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_get_text(
        vocab: *const llama_vocab,
        token: llama_token,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_token_get_score(vocab: *const llama_vocab, token: llama_token) -> f32;
}
extern "C" {
    pub fn llama_token_get_attr(vocab: *const llama_vocab, token: llama_token) -> llama_token_attr;
}
extern "C" {
    pub fn llama_token_is_eog(vocab: *const llama_vocab, token: llama_token) -> bool;
}
extern "C" {
    pub fn llama_token_is_control(vocab: *const llama_vocab, token: llama_token) -> bool;
}
extern "C" {
    pub fn llama_token_bos(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_eos(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_eot(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_cls(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_sep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_nl(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_pad(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_add_bos_token(vocab: *const llama_vocab) -> bool;
}
extern "C" {
    pub fn llama_add_eos_token(vocab: *const llama_vocab) -> bool;
}
extern "C" {
    pub fn llama_token_fim_pre(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_fim_suf(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_fim_mid(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_fim_pad(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_fim_rep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_fim_sep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_cls(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    #[doc = " @details Convert the provided text into tokens.\n @param tokens The tokens pointer must be large enough to hold the resulting tokens.\n @return Returns the number of tokens on success, no more than n_tokens_max\n @return Returns a negative number on failure - the number of tokens that would have been returned\n @param add_special Allow to add BOS and EOS tokens if model is configured to do so.\n @param parse_special Allow tokenizing special and/or control tokens which otherwise are not exposed and treated\n                      as plaintext. Does not insert a leading space."]
    pub fn llama_tokenize(
        vocab: *const llama_vocab,
        text: *const ::std::os::raw::c_char,
        text_len: i32,
        tokens: *mut llama_token,
        n_tokens_max: i32,
        add_special: bool,
        parse_special: bool,
    ) -> i32;
}
extern "C" {
    pub fn llama_token_to_piece(
        vocab: *const llama_vocab,
        token: llama_token,
        buf: *mut ::std::os::raw::c_char,
        length: i32,
        lstrip: i32,
        special: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @details Convert the provided tokens into text (inverse of llama_tokenize()).\n @param text The char pointer must be large enough to hold the resulting text.\n @return Returns the number of chars/bytes on success, no more than text_len_max.\n @return Returns a negative number on failure - the number of chars/bytes that would have been returned.\n @param remove_special Allow to remove BOS and EOS tokens if model is configured to do so.\n @param unparse_special If true, special tokens are rendered in the output."]
    pub fn llama_detokenize(
        vocab: *const llama_vocab,
        tokens: *const llama_token,
        n_tokens: i32,
        text: *mut ::std::os::raw::c_char,
        text_len_max: i32,
        remove_special: bool,
        unparse_special: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " Apply chat template. Inspired by hf apply_chat_template() on python.\n Both \"model\" and \"custom_template\" are optional, but at least one is required. \"custom_template\" has higher precedence than \"model\"\n NOTE: This function does not use a jinja parser. It only support a pre-defined list of template. See more: https://github.com/ggml-org/llama.cpp/wiki/Templates-supported-by-llama_chat_apply_template\n @param tmpl A Jinja template to use for this chat. If this is nullptr, the models default chat template will be used instead.\n @param chat Pointer to a list of multiple llama_chat_message\n @param n_msg Number of llama_chat_message in this chat\n @param add_ass Whether to end the prompt with the token(s) that indicate the start of an assistant message.\n @param buf A buffer to hold the output formatted prompt. The recommended alloc size is 2 * (total number of characters of all messages)\n @param length The size of the allocated buffer\n @return The total number of bytes of the formatted prompt. If is it larger than the size of buffer, you may need to re-alloc it and then re-apply the template."]
    pub fn llama_chat_apply_template(
        tmpl: *const ::std::os::raw::c_char,
        chat: *const llama_chat_message,
        n_msg: usize,
        add_ass: bool,
        buf: *mut ::std::os::raw::c_char,
        length: i32,
    ) -> i32;
}
extern "C" {
    pub fn llama_chat_builtin_templates(
        output: *mut *const ::std::os::raw::c_char,
        len: usize,
    ) -> i32;
}
pub type llama_sampler_context_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_sampler_i {
    pub name: ::std::option::Option<
        unsafe extern "C" fn(smpl: *const llama_sampler) -> *const ::std::os::raw::c_char,
    >,
    pub accept:
        ::std::option::Option<unsafe extern "C" fn(smpl: *mut llama_sampler, token: llama_token)>,
    pub apply: ::std::option::Option<
        unsafe extern "C" fn(smpl: *mut llama_sampler, cur_p: *mut llama_token_data_array),
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(smpl: *mut llama_sampler)>,
    pub clone: ::std::option::Option<
        unsafe extern "C" fn(smpl: *const llama_sampler) -> *mut llama_sampler,
    >,
    pub free: ::std::option::Option<unsafe extern "C" fn(smpl: *mut llama_sampler)>,
}
#[test]
fn bindgen_test_layout_llama_sampler_i() {
    const UNINIT: ::std::mem::MaybeUninit<llama_sampler_i> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_sampler_i>(),
        48usize,
        concat!("Size of: ", stringify!(llama_sampler_i))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_sampler_i>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_sampler_i))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accept) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(accept)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apply) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(apply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clone) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(clone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(free)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_sampler {
    pub iface: *const llama_sampler_i,
    pub ctx: llama_sampler_context_t,
}
#[test]
fn bindgen_test_layout_llama_sampler() {
    const UNINIT: ::std::mem::MaybeUninit<llama_sampler> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_sampler>(),
        16usize,
        concat!("Size of: ", stringify!(llama_sampler))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_sampler>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_sampler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler),
            "::",
            stringify!(iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler),
            "::",
            stringify!(ctx)
        )
    );
}
extern "C" {
    pub fn llama_sampler_init(
        iface: *const llama_sampler_i,
        ctx: llama_sampler_context_t,
    ) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_name(smpl: *const llama_sampler) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_sampler_accept(smpl: *mut llama_sampler, token: llama_token);
}
extern "C" {
    pub fn llama_sampler_apply(smpl: *mut llama_sampler, cur_p: *mut llama_token_data_array);
}
extern "C" {
    pub fn llama_sampler_reset(smpl: *mut llama_sampler);
}
extern "C" {
    pub fn llama_sampler_clone(smpl: *const llama_sampler) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_free(smpl: *mut llama_sampler);
}
extern "C" {
    pub fn llama_sampler_chain_init(params: llama_sampler_chain_params) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_chain_add(chain: *mut llama_sampler, smpl: *mut llama_sampler);
}
extern "C" {
    pub fn llama_sampler_chain_get(chain: *const llama_sampler, i: i32) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_chain_n(chain: *const llama_sampler) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llama_sampler_chain_remove(chain: *mut llama_sampler, i: i32) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_init_greedy() -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_init_dist(seed: u32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Sorts candidate tokens by their logits in descending order and calculate probabilities based on logits.\n NOTE: Avoid using on the full vocabulary as the sorting can become slow. For example, apply top-k or top-p sampling first."]
    pub fn llama_sampler_init_softmax() -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Top-K sampling described in academic paper \"The Curious Case of Neural Text Degeneration\" https://arxiv.org/abs/1904.09751"]
    pub fn llama_sampler_init_top_k(k: i32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Nucleus sampling described in academic paper \"The Curious Case of Neural Text Degeneration\" https://arxiv.org/abs/1904.09751"]
    pub fn llama_sampler_init_top_p(p: f32, min_keep: usize) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Minimum P sampling as described in https://github.com/ggml-org/llama.cpp/pull/3841"]
    pub fn llama_sampler_init_min_p(p: f32, min_keep: usize) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Locally Typical Sampling implementation described in the paper https://arxiv.org/abs/2202.00666."]
    pub fn llama_sampler_init_typical(p: f32, min_keep: usize) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " #details Updates the logits l_i` = l_i/t. When t <= 0.0f, the maximum logit is kept at it's original value, the rest are set to -inf"]
    pub fn llama_sampler_init_temp(t: f32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Dynamic temperature implementation (a.k.a. entropy) described in the paper https://arxiv.org/abs/2309.02772."]
    pub fn llama_sampler_init_temp_ext(t: f32, delta: f32, exponent: f32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details XTC sampler as described in https://github.com/oobabooga/text-generation-webui/pull/6335"]
    pub fn llama_sampler_init_xtc(p: f32, t: f32, min_keep: usize, seed: u32)
        -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Top n sigma sampling as described in academic paper \"Top-n: Not All Logits Are You Need\" https://arxiv.org/pdf/2411.07641"]
    pub fn llama_sampler_init_top_n_sigma(n: f32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Mirostat 1.0 algorithm described in the paper https://arxiv.org/abs/2007.14966. Uses tokens instead of words.\n @param candidates A vector of `llama_token_data` containing the candidate tokens, their probabilities (p), and log-odds (logit) for the current position in the generated text.\n @param tau  The target cross-entropy (or surprise) value you want to achieve for the generated text. A higher value corresponds to more surprising or less predictable text, while a lower value corresponds to less surprising or more predictable text.\n @param eta The learning rate used to update `mu` based on the error between the target and observed surprisal of the sampled word. A larger learning rate will cause `mu` to be updated more quickly, while a smaller learning rate will result in slower updates.\n @param m The number of tokens considered in the estimation of `s_hat`. This is an arbitrary value that is used to calculate `s_hat`, which in turn helps to calculate the value of `k`. In the paper, they use `m = 100`, but you can experiment with different values to see how it affects the performance of the algorithm.\n @param mu Maximum cross-entropy. This value is initialized to be twice the target cross-entropy (`2 * tau`) and is updated in the algorithm based on the error between the target and observed surprisal."]
    pub fn llama_sampler_init_mirostat(
        n_vocab: i32,
        seed: u32,
        tau: f32,
        eta: f32,
        m: i32,
    ) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Mirostat 2.0 algorithm described in the paper https://arxiv.org/abs/2007.14966. Uses tokens instead of words.\n @param candidates A vector of `llama_token_data` containing the candidate tokens, their probabilities (p), and log-odds (logit) for the current position in the generated text.\n @param tau  The target cross-entropy (or surprise) value you want to achieve for the generated text. A higher value corresponds to more surprising or less predictable text, while a lower value corresponds to less surprising or more predictable text.\n @param eta The learning rate used to update `mu` based on the error between the target and observed surprisal of the sampled word. A larger learning rate will cause `mu` to be updated more quickly, while a smaller learning rate will result in slower updates.\n @param mu Maximum cross-entropy. This value is initialized to be twice the target cross-entropy (`2 * tau`) and is updated in the algorithm based on the error between the target and observed surprisal."]
    pub fn llama_sampler_init_mirostat_v2(seed: u32, tau: f32, eta: f32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Intializes a GBNF grammar, see grammars/README.md for details.\n @param vocab The vocabulary that this grammar will be used with.\n @param grammar_str The production rules for the grammar, encoded as a string. Returns an empty grammar if empty. Returns NULL if parsing of grammar_str fails.\n @param grammar_root The name of the start symbol for the grammar."]
    pub fn llama_sampler_init_grammar(
        vocab: *const llama_vocab,
        grammar_str: *const ::std::os::raw::c_char,
        grammar_root: *const ::std::os::raw::c_char,
    ) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_init_grammar_lazy(
        vocab: *const llama_vocab,
        grammar_str: *const ::std::os::raw::c_char,
        grammar_root: *const ::std::os::raw::c_char,
        trigger_words: *mut *const ::std::os::raw::c_char,
        num_trigger_words: usize,
        trigger_tokens: *const llama_token,
        num_trigger_tokens: usize,
    ) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Lazy grammar sampler, introduced in https://github.com/ggml-org/llama.cpp/pull/9639\n @param trigger_patterns A list of patterns that will trigger the grammar sampler. Pattern will be matched from the start of the generation output, and grammar sampler will be fed content starting from its first match group.\n @param trigger_tokens A list of tokens that will trigger the grammar sampler. Grammar sampler will be fed content starting from the trigger token included."]
    pub fn llama_sampler_init_grammar_lazy_patterns(
        vocab: *const llama_vocab,
        grammar_str: *const ::std::os::raw::c_char,
        grammar_root: *const ::std::os::raw::c_char,
        trigger_patterns: *mut *const ::std::os::raw::c_char,
        num_trigger_patterns: usize,
        trigger_tokens: *const llama_token,
        num_trigger_tokens: usize,
    ) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " NOTE: Avoid using on the full vocabulary as searching for repeated tokens can become slow. For example, apply top-k or top-p sampling first."]
    pub fn llama_sampler_init_penalties(
        penalty_last_n: i32,
        penalty_repeat: f32,
        penalty_freq: f32,
        penalty_present: f32,
    ) -> *mut llama_sampler;
}
extern "C" {
    #[doc = "  @details DRY sampler, designed by p-e-w, as described in: https://github.com/oobabooga/text-generation-webui/pull/5677, porting Koboldcpp implementation authored by pi6am: https://github.com/LostRuins/koboldcpp/pull/982"]
    pub fn llama_sampler_init_dry(
        vocab: *const llama_vocab,
        n_ctx_train: i32,
        dry_multiplier: f32,
        dry_base: f32,
        dry_allowed_length: i32,
        dry_penalty_last_n: i32,
        seq_breakers: *mut *const ::std::os::raw::c_char,
        num_breakers: usize,
    ) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_init_logit_bias(
        n_vocab: i32,
        n_logit_bias: i32,
        logit_bias: *const llama_logit_bias,
    ) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_init_infill(vocab: *const llama_vocab) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_get_seed(smpl: *const llama_sampler) -> u32;
}
extern "C" {
    pub fn llama_sampler_sample(
        smpl: *mut llama_sampler,
        ctx: *mut llama_context,
        idx: i32,
    ) -> llama_token;
}
extern "C" {
    #[doc = " @details Build a split GGUF final path for this chunk.\n          llama_split_path(split_path, sizeof(split_path), \"/models/ggml-model-q4_0\", 2, 4) => split_path = \"/models/ggml-model-q4_0-00002-of-00004.gguf\""]
    pub fn llama_split_path(
        split_path: *mut ::std::os::raw::c_char,
        maxlen: usize,
        path_prefix: *const ::std::os::raw::c_char,
        split_no: ::std::os::raw::c_int,
        split_count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @details Extract the path prefix from the split_path if and only if the split_no and split_count match.\n          llama_split_prefix(split_prefix, 64, \"/models/ggml-model-q4_0-00002-of-00004.gguf\", 2, 4) => split_prefix = \"/models/ggml-model-q4_0\""]
    pub fn llama_split_prefix(
        split_prefix: *mut ::std::os::raw::c_char,
        maxlen: usize,
        split_path: *const ::std::os::raw::c_char,
        split_no: ::std::os::raw::c_int,
        split_count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llama_print_system_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_log_set(log_callback: ggml_log_callback, user_data: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_perf_context_data {
    pub t_start_ms: f64,
    pub t_load_ms: f64,
    pub t_p_eval_ms: f64,
    pub t_eval_ms: f64,
    pub n_p_eval: i32,
    pub n_eval: i32,
}
#[test]
fn bindgen_test_layout_llama_perf_context_data() {
    const UNINIT: ::std::mem::MaybeUninit<llama_perf_context_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_perf_context_data>(),
        40usize,
        concat!("Size of: ", stringify!(llama_perf_context_data))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_perf_context_data>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_perf_context_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_start_ms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(t_start_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_load_ms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(t_load_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_p_eval_ms) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(t_p_eval_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_eval_ms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(t_eval_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_p_eval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(n_p_eval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_eval) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(n_eval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct llama_perf_sampler_data {
    pub t_sample_ms: f64,
    pub n_sample: i32,
}
#[test]
fn bindgen_test_layout_llama_perf_sampler_data() {
    const UNINIT: ::std::mem::MaybeUninit<llama_perf_sampler_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_perf_sampler_data>(),
        16usize,
        concat!("Size of: ", stringify!(llama_perf_sampler_data))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_perf_sampler_data>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_perf_sampler_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_sample_ms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_sampler_data),
            "::",
            stringify!(t_sample_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_sample) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_sampler_data),
            "::",
            stringify!(n_sample)
        )
    );
}
extern "C" {
    pub fn llama_perf_context(ctx: *const llama_context) -> llama_perf_context_data;
}
extern "C" {
    pub fn llama_perf_context_print(ctx: *const llama_context);
}
extern "C" {
    pub fn llama_perf_context_reset(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_perf_sampler(chain: *const llama_sampler) -> llama_perf_sampler_data;
}
extern "C" {
    pub fn llama_perf_sampler_print(chain: *const llama_sampler);
}
extern "C" {
    pub fn llama_perf_sampler_reset(chain: *mut llama_sampler);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ggml_backend_buffer {
    pub _address: u8,
}
